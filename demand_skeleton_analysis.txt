将需求按模块划分：
	1.bootloader
	思路一：
		loader1：
			放置在boot setctor中；
			加载loader2并将控制转移到loader2；
			需要理解FAT12文件系统
				先建立一个虚拟软盘（格式化为FAT12文件系统），向文件系统中添加文件，通过od查看文件系统结构变化
				再构造一个boot sector，在该sector中加入BPB信息，将该sector写入一个软盘，该软盘即被格式化为FAT12文件系统
				随后可以将loader2写入该文件系统中，loader1通过FAT12文件系统读取
				
				需要一个根据文件名（仅限于根目录中）在FAT12中查找，并读取其全部内容到指定缓存区的过程
					首先，通过读取扇区过程读取根目录所在的扇区
					按照文件名查找文件，未找到则提示出错
					根据文件第一个cluster号，通过读取扇区过程，读取一个cluster到指定缓存区
					再查看FAT表（一个过程），是否为最后一个，不是则继续读取剩余cluster
					
			需要一个打印函数
		loader2：
			放置在FAT12文件系统中；
			
			协定loader1转移到loader2的过程（段基地址、段内偏移）
			
			获取可用内存信息
			设置GDT
			lgdtr
			打开A20
			打开CR0的PE位
			刷新CS/DS/SS/ES/FS/GS段描述符高速缓存器
			
			加载kernel并将控制转移到kernel
				理解ELF格式
				学习C语言和汇编语言混合编程
	思路二：
		使用grub做loader
		
		理解ld如何链接程序
		了解grub将内核加载进内存后，内存中的状态
	2.中断、系统调用管理机制
		构想：
			在IDT中设置中断门和陷阱门，并且中断门的DPL均为0，陷阱门DPL为3，中断门供异常和外部硬件中断使用，陷阱门用于系统调用，因此在系统调用中是可以被中断的。
			关于中断处理的架构，参考interrupt_process_explain.png；
			用户程序应该通过int 255发起系统调用，并在eax中指定系统调用号（指定进行哪个系统调用）；参数传递方式则参照cdecl；返回值保存在eax中，和cdecl保持一致；
			用户进程通过系统调用进入内核后，内核将根据系统调用号在系统调用表中找到对应的处理函数并转而执行该函数；其返回的结果保存在该进程的中断帧中的eax中；然后按照通用的中断返回机制返回用户模式；按照cdecl，调用者可像调用普通函数一样获得系统调用的返回值；
			
			系统调用表为一个函数指针列表，指向具体执行系统调用工作的函数，所使用的函数原型是：
				int32_t func(void)
			其返回值用作该系统调用的结果；
			
			总体思路是：
				定义IDT的相关结构
				定义各个中断处理程序
				设置好IDT
				配置8259A PIC，初始时禁止任何中断进入
				定义中断的分发处理
			注意：
				在内核中不能使用int n的形式发起那些本身就有错误代码的中断，这样会破坏栈平衡；
				不要发起以20-31这些中断向量相关的中断，因为这些未定义（20也包括在内，因为测试的bochs上可能没有启用该CPU特性）；
				在测试中，有出现过未处理的中断0x27（但实际该中断应该已经在IMR中屏蔽），怀疑是suprious IRQ；			
		文件的组织结构：
			idt.h 供init使用，应该提供：定义IDT条目结构、定义IDTR结构、
			      定义用于保存中断发生时的现场信息的结构、初始化IDT和注册处理特定中断的函数原型
			idt.c 实现初始化IDT、注册处理特定中断的函数
			idt.asm 实现中断处理程序中通用的保护现场过程和恢复现场过程、刷新idtr的过程
			8259A.c 实现初始化两个8259A PIC、设置8259A的IMR
			8259A.h 提供初始化8259A PIC、设置IMR的函数原型、IRQ与中断向量的映射
			syscall.c 提供支撑系统调用的框架函数实现
			syscall.h 提供上述函数的接口声明
		提供的功能：
			初始化IDT：
				建立IDT表，刷新IDTR寄存器，按照需要注册处理特定中断的函数
			注册处理特定中断的函数：
				将特定函数记录在中断处理函数表中
			初始化8259A PIC
				发送四个ICW
				ICW1: 0001 0001 (0x11)，通过命令端口写入
				ICW2: 
					MASTER: 0x20(master 8259A PIC被映射到0x20-0x27这8个中断向量)，通过数据端口写入
					SLAVE: 0x28(slave 8259A PIC被映射到0x28-0x2F这8个中断向量)，通过数据端口写入
				ICW3:
					MASTER: 0X04(MASTER上的IRQ2被用作链接SLAVE)，通过数据端口写入
					SLAVE: 0x02(SLAVE的INT引脚链接到MASTER的IRQ2上)，通过数据端口写入
				ICW4: 0x01，通过数据端口写入
				设置主从片的IMR，禁止任何中断进入
			发送EOI给PIC
				向master PIC发送EOI
				如果中断向量大于等于0x28
					同时需要向slave PIC发送EOI
			各个中断入口：
				根据具体中断的不同，压入中断向量号，如果CPU没有压入错误码，则还需压入错误码；
			通用的保存现场：
				保存中断现场到中断帧中；
			通用的恢复现场，从中断中返回：
				恢复中断帧中的信息；
				回到原来的状态继续执行；
			中断分发：
				根据中断向量，分类处理
				内部中断或异常（0~31）
					如果有相关处理函数
						调用相关函数
					否则输出中断信息，并PANIC
				外部硬件中断（通过8259A PIC发起的中断，目前设置为32~47）：
					键盘、时钟、IDE硬盘中断处理：
						发送EOI
						调用相关中断处理函数
					COM接口、软盘等硬件中断：
						目前暂未提供相关支持，直接输出中断信息
				通过int 255发起的中断（系统调用）：
					使当前进程的中断帧指针指向当前中断帧的位置；
					调用函数，将控制分发到指定的系统调用函数上；
				其他中断：
					输出中断信息，并PANIC
			
			根据当前进程指定的系统调用号，执行对应的系统调用函数：
				如果系统调用号在允许范围内且有效
					调用对应的函数；
					保存返回结果到当前进程的中断帧中的eax中；
				否则PANIC；
			检查当前进程用户地址空间地址addr是否在非用户栈的有效地址空间中，即是否可以通过该地址访问至少一个字节的数据：
				addr 用户地址空间中的地址
				成功返回1，失败返回0
				如果addr>=PROC_LOAD_ADDR且addr<PROC_LOAD_ADDR+当前进程对应PCB.size
					返回1；
				否则返回0；
				
			检查当前进程用户地址空间地址addr是否在用户栈中，即是否可以通过该地址访问至少一个字节的数据：
				addr 用户地址空间中的地址
				成功返回1，失败返回0
				
				如果addr>=用户栈起始位置且addr<用户栈结束位置
					返回1；
				否则返回0；
				
			从当前进程用户地址空间addr处取出一个4字节大小的参数到ap指定位置处：
				addr 用户地址空间中的地址
				ap 指向保存参数的位置
				成功返回0且结果将写入*ap中，失败返回-1且*ap中的值不会被修改；
				
				调用函数，检查addr和addr+3是否都在用户栈中或者都在非用户栈的有效地址空间中
				如果是
					从addr处读取4字节到ap指向的位置中；
					返回0；
				返回-1；
			检查当前进程用户地址空间addr处开始是否为一个NUL结尾的字符串：
				addr 用户地址空间中的地址
				是则返回其长度，否则返回-1；
				
				调用函数，检查addr是否属于非栈空间的有效用户地址空间地址
				如果是
					如果addr所指示字符为NUL
						停止检查，返回此时已经检查过的字符个数；
					令addr指向下一个字符；
					检查addr是否属于非栈空间的有效用户地址空间地址
					如果是
						则继续上述循环；
					返回-1；
				调用函数，检查addr是否属于栈空间
				如果是
					如果addr所指示字符为NUL
						停止检查，返回此时已经检查过的字符个数；
					令addr指向下一个字符；
					检查addr是否属于栈空间
					如果是
						则继续上述循环；
					返回-1；
				返回-1；
			
			从当前进程用户栈中取出第n个4字节大小的参数写入到ap所指向的位置，遵循cdecl：
				n 从左往右第n个4字节大小的参数，n从0开始
				ap 指向保存参数的位置
				成功返回0且参数将写入ap所指向的位置，失败返回-1且*ap中的值不会被修改；
				
				根据进程用户栈当前esp的位置，找到第n个参数的地址m；
				调用函数，从m处取出4字节大小的整数，写入ap所指向的位置，并返回该函数调用的结果；
			从当前进程用户栈取出第n个4字节大小的参数作为指针，写入到pp所指向的位置，并检查该指针指向的对象是否在进程的有效用户地址空间中，遵循cdecl：
				n 从左往右第n个4字节大小的参数，n从0开始
				pp 指向保存指针的位置
				size 该指针指向的对象大小
				成功返回0且参数将写入pp所指向的位置，失败返回-1且*pp中的值不会被修改；
				
				调用函数，从当前进程用户栈中取出第n个4字节大小的参数，保存在tmp中，返回结果保存在ret中；
				如果ret等于-1
					返回-1；
				如果tmp+size<tmp
					说明溢出了，返回-1；
				如果tmp和tmp+size都在用户栈中或者都在非用户栈的有效地址空间中
					将tmp写入pp所指向的位置；
					返回0；
				返回-1；
			从当前进程用户栈中取出第n个4字节大小的参数作为字符串指针，写入pp所指向的位置，并检查该指针指向的对象是否为NUL结尾的字符串，遵循cdecl：
				n 从左往右第n个4字节大小的参数，n从0开始
				pp 指向保存指针的位置
				如果参数取出成功且所指向对象确实是NUL结尾的字符串，则返回字符串长度且字符串指针将写入pp所指向的位置，否则返回-1且*pp中的值不会被修改；
				
				调用函数，从当前进程用户栈中取出第n个4字节大小的参数，保存在tmp中，返回结果保存在ret中；
				如果ret等于-1
					返回-1；
				调用函数，检查tmp处是否为一个NUL结尾的字符串，返回结果保存在ret2中；
				如果ret2为-1
					返回-1；
				将tmp写入pp所指向的位置；
				返回ret2；
				
	3.内存管理
		《1》基础的内存管理：
			构想：
				每个进程的地址空间分为用户地址空间和内核地址空间，调度进程则只有内核地址空间；不管什么进程，其内核地址空间都是相同的，在创建进程时，所有可用物理内存均被映射到内核地址空间中（根据grub提供的mmap信息），之后一般不再修改；用户地址空间所需物理内存同样从内核地址空间分配，然后再映射到用户地址空间，也就是说对于用户地址空间映射的物理内存，在内核地址空间中同样存在映射；这种设计，能够保证对于每个进程，其内核空间地址都是统一的，但其用户空间地址则是独立的，而且一个进程可以通过内核空间地址访问另一个进程的用户空间数据，这有利于fork/exec/wait/exit这类调用的实现。
				设定KERNEL_VD_OFFSET为0xC0000000，内核地址空间从这里开始；设定kernel_start_addr/kernel_end_addr分别为内核被加载到内存之后的起始虚拟地址和结束虚拟地址。目前暂定只支持64MB(0x4000000，SUPPORT_MEM_SIZE)的内存，使用4KB大小的页面。
				具体化内存布局如下：
					0x0 ~ KERNEL_VD_OFFSET，映射到内核所分配的物理内存，用作用户地址空间（代码、数据、用户栈、堆）；
					KERNEL_VD_OFFSET ~ KERNEL_VD_OFFSET+0x100000，映射到0x0 ~ 0x100000，暂不使用；
					KERNEL_VD_OFFSET+0x100000 ~ PAGE_UPPER_ALIGN(kernel_end_addr)，映射到0x100000 ~ PAGE_UPPER_ALIGN(K_V2P(kernel_end_addr))，用于内核代码、数据、初始内核栈、初始内核分页结构；
					PAGE_UPPER_ALIGN(kernel_end_addr) ~ KERNEL_VD_OFFSET+SUPPORT_MEM_SIZE，映射到PAGE_UPPER_ALIGN(K_V2P(kernel_end_addr)) ~ SUPPORT_MEM_SIZE，剩余空闲物理内存；
				这里假定从物理地址0x100000开始为内核管理的内存，通过grub来确定其结束位置；每个新建进程都拥有这样的内存布局。
				将进入分页模式的工作分为两部分（boot1/boot2）：
					使boot1的LMA和VMA相同，boot2的LMA仍然紧接boot1的LMA，但VMA设置为从KERNEL_VD_OFFSET开始。boot1负责接受从GRUB传来的控制，建立页目录和两类页表：
						第一类页表负责将虚拟地址0x0 ~ SUPPORT_MEM_SIZE映射到物理地址0x0 ~ SUPPORT_MEM_SIZE，便于boot1开启分页模式之后，仍能继续执行；
						第二类页表负责将虚拟地址KERNEL_VD_OFFSET ~ KERNEL_VD_OFFSET+SUPPORT_MEM_SIZE映射到物理地址0x0 ~ SUPPORT_MEM_SIZE，这类页表就是内核之后的运行地址空间；
					然后开启分页模式，转入到boot2部分。由于提前建立上述两类页表，所以在开启分页模式之后，进入boot2部分之前，仍然能正常执行指令。在进入boot2部分之后，撤销掉第1类页表，使得0-3GB的线性地址空间能被用户程序使用，并根据mmap信息初始化基础的内存管机制，再继续做其余的初始化工作。
					在建立这两类页表时，事实上只需要建立一类页表，让两类不同的页目录项指向这类页表即可；同时，初始时页目录条目属性设置为用户特权级别的，而页表条目则设置为内核特权级别的，对于其他新建分页结构也是如此，一般情况使用页表条目进行特权级控制。
					
					在开启分页之后，转入boot2之前，应该修改Multiboot information结构、栈(esp/ebp)的地址、显存地址，以保证撤销掉第1类页表之后还能正确访问这些地址；这些数据的物理地址仍然不改变，也就是说不会再使用新的内存区域，仅仅修改其线性地址。
				
				根据bochs上的实验，配置64MB的内存并不代表所有的物理内存均可访问，将根据mmap信息对分页结构进行调整（将某些页表项置0）。
				根据Multiboot 0.6.96，不能保证启动信息保存的位置，但是当前仍然假设其信息均保存在0x100000以下的位置；对于0x0 ~ SUPPORT_MEM_SIZE之间的内存全部都映射，而不管其中可能存在的非available区域；设定内核中可用于动态分配的内存范围从PAGE_UPPER_ALIGN(kernel_end_addr)到从该地址往上的第一个不可用（非available）内存页位置。
				将可用于动态分配的内存通过单向链表链接起来，链表头指向第一个空闲页面，该空闲页面的开头位置存放指向下一个空闲页面的指针，如此下去，最后一个空闲页面中的指针置为NULL；每次分配/释放则是对空闲页面链表进行抽取/插入操作，每次只能分配或释放一个页面；为分配和释放操作提供两类接口，一类接口在操作时需要请求锁，另一类则不需要，在已经关闭中断的情况下可以使用无需锁的接口，而在打开中断的时候使用需要请求锁的接口；
				链表头结构定义如下：
					flags，表明当前是否已经上锁（BUSY）；
					head，空闲页指针，指向链表中第一个空闲页面；
					end_addr，可用于动态分配的内存结束位置；
				系统只需要定义一个链表头结构变量。
				
			需要的接口：
				启动信息结构操作接口：
					检查指定的物理页框是否为有效物理内存，成功返回1，失败返回0（物理地址paddr）：
						遍历mmap条目，如果该页框在有效（available）物理内存中，则返回1，否则返回0；
					显示该机器的物理内存布局信息：
				
				刷新整个TLB中除具有全局属性的其他条目：
					
				刷新CR3/读取CR3
					刷新CR3时，会更换页目录，更改PCD/PWT属性，同时刷新整个TLB（除具有全局属性的条目之外的所有条目）；
					
				处理page fault
					目前暂时只输出导致page fault的原因，不作进一步处理；
					
				在虚拟地址（线性地址）和物理地址之间转换，虚拟地址仅限于KERNEL_VD_OFFSET ~ KERNEL_VD_OFFSET + SUPPORT_MEM_SIZE，物理地址仅限于0x0 ~ SUPPORT_MEM_SIZE
					p2v/v2p
				
				初始化页分配机制：
					从PAGE_UPPER_ALIGN(kernel_end_addr)开始，直到K_P2V(SUPPORT_MEM_SIZE)，记录所遇到的第一个不可用（非available）内存页的地址addr；
					将addr写入链表头结构的end_addr域中；
					设置链表头结构中的flags为UN-BUSY；
					将所有可用空闲页链接起来，第一个空闲页位置写入链表头结构中的head域；
					
				无需锁，分配一个清零过的空闲页，返回该页面起始虚拟地址：
					如果已经没有空闲页可分配，则返回NULL；
					从链表头中拿出一个空闲页面pg，并使链表头中的指针指向链表中下一个空闲页；
					清零所分配的空闲页；
					返回所分配的空闲页起始地址；
					
				无需锁，回收一个PAGE_DOWN_ALIGN(vaddr)所指定的页面（页面地址vaddr）：
					检查vaddr指定的页面是否在PAGE_UPPER_ALIGN(kernel_end_addr) ~ KERNEL_VD_OFFSET+SUPPORT_MEM_SIZE范围里有效的内存中；
					如果有一项不成立则PANIC；
					使用1来填充该页面，期望能检查出一些错误；
					将该页面插入链表中；
					
				锁住链表头：
					关闭中断；
					如果flags为BUSY的
						睡眠在链表头结构变量上；
						返回继续检查flags变量；
					设置flags为BUSY的；
					恢复原先的中断状态；
					
				解锁链表头：
					如果flags不是BUSY的
						可能有错误发生，PANIC；
					清除flags中的BUSY标志；
					唤醒在链表头结构变量上睡眠的进程；
					
				需要锁，分配一个清零过的空闲页，返回该页的起始虚拟地址：
					调用函数，锁住链表头；
					调用函数，分配一个清零过的空闲页，返回其结果；
					调用函数，解锁链表头；
					
				需要锁，回收一个空闲页（空闲页地址vaddr）：
					调用函数，锁住链表头；
					调用函数，回收vaddr指示的空闲页；
					调用函数，解锁链表头；
			文件的组织结构：
				multiboot.c: 提供用于处理与Multiboot相关数据结构的函数；
				multiboot.h: 提供Multiboot相关数据结构定义，同时包含指向grub提供的Multiboot information
						 struct的指针的拓展声明（在init.c中给出该定义）；
				vmm.c: 基础vm操作函数；
				vmm.h：提供相关函数原型、页大小等常量和相关宏；
				page_fault.c: page fault的处理；
		
		《2》高层的内存管理工具：
			构想：
				该层在上一层的基础上，为进程创建、操纵进程内存等提供相关工具函数接口。
				
			需要的接口：
				获得虚拟地址在指定分页结构中所对应的页表条目虚拟地址：
					create标志指定是否需要创建相关页表
					pgdir指定页目录虚拟地址
					addr指定虚拟地址
					
					使用addr的页目录索引部分查找页目录，找出对应的页目录条目pde；
					如果pde无效（不存在映射页表）
						如果指定create
							分配一页清零过的内存存放中间页表；
							在pde中写入映射关系，pde设置为用户特权级的；
						否则
							返回NULL；
					从pde中取出中间页表的物理地址，调用函数转化为虚拟地址；
					使用addr的页表索引部分查找中间页表，找出对应的页表条目pte；
					返回pte地址；
							
				在指定分页结构中，将一段虚拟地址空间映射到一段物理地址空间：
					pgdir指定页目录虚拟地址
					vaddr指定起始虚拟地址，必须按页对齐
					size指定空间大小
					paddr指定起始物理地址，必须按页对齐
					pte_attr指定页表表项的属性
					
					让size按页对齐，不足一页的部分按一页计算；
					从vaddr到vaddr+size地址区间中，调用函数，获得每一页对应的pte地址，必要时创建中间页表，其对应的pde设置为用户特权级别的；
					如果该位置已经存在映射
						PANIC；
					使用对应物理地址和pte_attr设置pte；

				创建进程的初始内核地址空间，并返回新建页目录的虚拟地址：
					分配一页清零的内存存放新页目录pgdir；
					调用函数，将物理地址区域0x0 ~ SUPPORT_MEM_SIZE映射到pgdir中的KERNEL_VD_OFFSET ~ KERNEL_VD_OFFSET + SUPPORT_MEM_SIZE处，对应PTE为系统特权级别，PDE为用户特权级别
					成功返回新建页目录的虚拟地址，失败PANIC；
					
				为pgdir的用户地址空间中start_addr到end_addr这段地址空间分配内存，成功返回end_addr，失败返回NULL且被分配的内存将被释放掉：
					pgdir 指定分页结构
					start_addr 起始地址，可以不按页对齐，分配时将从PAGE_UPPER_ALIGN(start_addr)开始
					end_addr 结束地址，可以不按页对齐，分配时将截至至PAGE_UPPER_ALIGN(end_addr)
					
					如果pgdir为NULL，则PANIC；
					如果end_addr大于KERNEL_VD_OFFSET
						返回NULL；
					如果end_addr小于等于start_addr
						返回start_addr
					
					令addr为PAGE_UPPER_ALIGN(start_addr)；
					如果addr < end_addr，则循环执行下述语句
						调用函数，分配一页清零的内存，结果保存在page中；
						如果page为NULL
							调用函数，释放pgdir中从start_addr到end_addr之间映射的内存（如果存在的话）；
							返回NULL；
						调用函数，将K_V2P(page)这页内存映射到pgdir中从addr开始的位置，PTE属性设置为用户特权级、可读可写；
						令addr向上偏移一个页面大小；
					返回end_addr；
					
					注意：如果end_addr小于等于start_addr，则不会分配内存，并且返回start_addr
				
				释放指定分页结构的用户地址空间中从start_addr到end_addr之间可能被映射的内存，成功返回start_addr，发生错误则PANIC：
					pgdir 指定分页结构
					start_addr 起始地址，可以不按页对齐，释放时从PAGE_UPPER_ALIGN(start_addr)开始
					end_addr 结束地址，可以不按页对齐，释放时将截至至PAGE_UPPER_ALIGN(end_addr)
					
					如果pgdir为NULL，则PANIC；
					如果end_addr大于KERNEL_VD_OFFSET
						PANIC；
					如果end_addr小于等于start_addr
						返回start_addr；
					
					令addr为PAGE_UPPER_ALIGN(start_addr)；
					如果addr小于end_addr，则循环执行下述语句
						调用函数，获得addr在pgdir中对应的页表项，结果保存在pte中；
						如果pte为NULL
							说明没有中间页表，从下一个4MB开始位置继续处理；
							令addr向上偏移4MB；
							令addr和0xFFC00000按位相与，结果保存在addr中；
							再令addr向下偏移一个页面大小；
						否则
							如果pte有效
								取出pte中的物理地址，结果保存在paddr中；
								调用函数，释放K_P2V(paddr)这个页面；
								将pte清零；
						令addr向上偏移一个页面大小；
					返回start_addr；
					
					注意：如果end_addr小于等于start_addr，则不会释放内存
				
				释放分页结构管理的内存以及整个分页结构，不包括内核地址空间所映射的内存，失败则PANIC：
					pgdir 待释放的分页结构
					
					如果pgdir为NULL，则PANIC；
					调用函数，释放pgdir中从PROC_LOAD_ADDR到KERNEL_VD_OFFSET之间可能被映射的内存；
					从头遍历pgdir的页目录项
						如果该目录项有效
							取出该目录项中的物理地址部分，结果保存在paddr中；
							调用函数，释放K_P2V(paddr)所对应的页面；
					调用函数，释放pgdir所占用的页面；
				
				将指定分页结构中的用户地址空间地址转换为内核地址空间地址，成功返回映射后结果，失败返回NULL：
					pgdir 指定分页结构
					uvaddr 指定用户地址空间地址
					
					如果pgdir为NULL，则PANIC；
					调用函数，获得uvaddr在pgdir中对应的页表项的地址，结果保存在pte中；
					如果pte为NULL或者pte无效或者pte所表示的条目没有设置用户特权
						返回NULL；
					取出pte中的物理地址，结果保存在paddr中；
					返回K_P2V(paddr) + PG_OFFSET(uvaddr)；
				
				从指定位置pos复制len个字节到指定分页结构pgdir中的addr处，成功返回0，失败返回-1：
					pgdir 指定分页结构
					addr 目标地址
					pos 起始位置
					len 需要复制的字节数
					
					如果pgdir为NULL，则PANIC；
					当len > 0时，循环执行下述语句
						调用函数，将addr转换为内核地址空间地址，结果保存在kvaddr中；
						如果kvaddr为NULL
							说明addr没有被映射到内存或者addr具有内核权限属性，返回-1；
						待复制的字节数n则取PAGE_DOWN_ALIGN(kvaddr)+PAGE_SIZE-kvaddr和len之间的最小值；
						调用函数，复制从pos开始的n个字节到kvaddr中；
						令len为其减去n之后的值；
						令addr/pos向上偏移n个字节位置；
					
					返回0；
					
					注意：
						该函数假定从addr到addr+len之间是存在内存映射的；
						该函数仅适用于复制数据到用户权限的地址空间中，即addr到addr+len之间的地址是具有用户权限的；
				创建一个指定地址空间的副本：
					pgdir: 被复制的地址空间；
					size: 从PROC_LOAD_ADDR开始的有效用户地址空间大小，不包括用户栈；
					成功返回所创建副本的页目录地址，失败返回NULL；
					
					调用函数，创建初始的进程地址空间，保存在new_pgdir中；
					针对从PROC_LOAD_ADDR到PAGE_UPPER_ALIGN(PROC_LOAD_ADDR+size)之间的每一页内存
						调用函数，获得该页内存在pgdir中对应的页表项条目，结果保存在pte中；
						如果无中间页表或者pte中没有设置P位
							跳过该页内存，继续处理下一页；
						调用函数，在new_pgdir中分配对应的位置的内存
						如果分配失败
							调用函数，释放与new_pgdir关联的所有内存；
							返回NULL；
						调用函数，获取上述分配内存在new_pgdir中对应的页表项条目，保存在new_pte中；
						转换pte以及new_pte中的物理地址为内核地址空间地址，并调用函数，将pte指定物理页复制到new_pte指定物理页中；
					调用函数，在new_pgdir中所设定用户栈的位置分配内存，用作用户栈；
					如果分配失败
						调用函数，释放与new_pgdir关联的所有内存；
						返回NULL；
					针对用户栈中的每一页内存
						调用函数，获得该页内存在pgdir中对应的页表条目，结果保存在pte中；
						调用函数，获取该页内存在new_pgdir中对应的页表项条目，保存在new_pte中；
						转换pte以及new_pte中的物理地址为内核地址空间地址，并调用函数，将pte指定物理页复制到new_pte指定物理页中；
					返回new_pgdir；
					
					注意：
					副本中用户地址空间内容是相同但独立的，内核地址空间内容是相同的但并不独立；
					如果原地址空间中有hole，则复制后的地址空间中也有hole；
					如果复制失败则之前所分配的内存均将被释放掉；
					
				创建进程的初始内核地址分页结构，并返回新建页目录的虚拟地址【注意该函数使用方式】
					函数执行逻辑等同于上述函数，但在建立映射关系时，使用的是接口是受限的！
					
					注意：在使用该接口时，要能够保证没有其他进程在使用带锁的内存分配接口
					
				获得虚拟地址在指定分页结构中所对应的页表条目虚拟地址【注意该函数使用方式】
					函数执行逻辑等同于上述函数，除了在分配内存时，使用的是不带锁的分配内存接口！
					
					注意：在使用该接口时，要能够保证没有其他进程在使用带锁的内存分配接口
					
				在指定分页结构中，将一段虚拟地址空间映射到一段物理地址空间【注意该函数使用方式】
					函数执行逻辑等同于上述函数，但在获取页表条目虚拟地址时，使用的是接口是受限的！
					
					注意：在使用该接口时，要能够保证没有其他进程在使用带锁的内存分配接口
					
				初始化第一个进程的用户地址空间
					pd: 指向该进程的分页结构
					init_proc_start_addr: init程序被加载到内存中的起始物理地址
					init_proc_size: init程序被加载进内存后的大小
					
					如果init_proc_size大于PAGE_SIZE，则PANIC；
					调用函数，分配一个清零过的页面pg；
					调用函数，在pd中，将pg对应的物理页框映射到PROC_LOAD_ADDR开始的位置，注意其对应PTE/PDE均为可读可写、用户特权级别；
					将从K_P2V(init_proc_start_addr)开始的init_proc_size大小的内存复制到页面pg中，这样等同于复制到了pd中PROC_LOAD_ADDR开始的位置；
					设置该进程的用户栈；
			
			文件的组织结构：
				vm_tools.c: 上述函数接口的实现；
				vm_tools.h: 相关函数接口声明；

	4.进程管理
		构想：
			在这个系统中，通过页表，使得每个进程都具有独立的地址空间，一部分为用户地址空间（0-3GB），另一部分为内核地址空间，参考内存管理部分。每个进程的用户空间中，从0x1000(PROC_LOAD_ADDR)开始依次是进程的指令、全局变量、大小可拓展的堆区、固定大小的栈区；栈区紧靠内核地址空间，在其下方安排一个未被映射的页，用于检测栈溢出；0x0 ~ PROC_LOAD_ADDR不映射，用于检测NULL指针；进程被创建时其有效用户地址空间包括初始的进程镜像和一个用户栈。
			在用户地址空间中运行时，使用用户指令、用户堆栈，处于RING3中；在内核地址空间运行时，使用内核指令、内核或者用户堆栈，处于RING0中。
			
			使用PCB（Process Control Block）来维护一个进程的状态，PCB中包含页表、内核栈位置、当前运行状态。具体结构参见PCB_explain。使用一张PCB表，跟踪系统中所有进程，表项数量为系统中并行进程数的最大值；状态为UNUSED的PCB可以被回收利用。
			每个进程拥有一个运行线程。当进程刚刚被创建时为NEWBORN状态，具备可执行条件时为RUNNABLE状态，正在占用当前CPU时为RUNNING状态，等待某种事件发生的过程中为SLEEPING，进程执行结束后等待父进程回收其资源时为ZOMBIE状态。
			每个进程都有用户栈（在用户空间中）和内核栈（在内核空间中）。当进程运行用户指令时，只有其用户栈被使用，其内核栈则是空的。然而当进程（系统调用、硬件中断、异常）进入内核时，内核代码就在进程的内核栈中执行；进程处于内核中时，其用户栈仍然保存着数据，只是暂时处于不活跃状态。进程交替地使用用户栈和内核栈。内核栈是用户代码无法使用的。
			内核栈和用户栈为固定4KB大小。
			进程不使用LDT，所有需要的段描述符都安装在GDT中。不是每个进程使用一个单独的TSS，而是共享共一个，TSS中不使用IO映射位图，所以在用户模式下的所有进程是无法执行I/O指令的。
			进程切换只能发生在内核模式中。进入内核模式后，首先切换到CPU上的scheduler内核线程，然后再切换到某个进程的内核线程中，并从内核模式返回用户模式执行。scheduler线程具有自己的内核上下文和内核栈（为系统初始化时使用的内核栈），其地址空间只具有内核部分，没有用户部分。
			进程初始创建时，其内核上下文中默认开启中断。在内核中，进程可以在需要时暂时关闭中断，执行关键代码之后，再恢复之前的中断状态，最多可以进行10次这样的嵌套操作。
			一个进程可以暂时休眠，等待某个特定事件发生，当该事件发生时，另一个进程可以唤醒它；在当前设计中，进程可以在一个等待队列上休眠，每次针对该等待队列的唤醒都将使所有在这个等待队列上休眠的进程RUNNABLE；目前使用内核地址空间中一个数据结构的地址作为每一个等待队列的标识。进程休眠之后，将会把CPU交给调度线程。进程从休眠中醒来后，应该再次检查所等待的事件是否已经发生。
			在目前的设计中，scheduler线程是不可调度的，所以scheduler不能睡眠；由于在scheduler中暂时的开启了外部硬件中断，所以在外部硬件中断处理程序中不能睡眠，因为这可能导致scheduler睡眠。
			系统通过fork操作创建一个当前进程的副本作为子进程，执行该操作的则为其父进程；fork创建的子进程默认拥有和父进程相同的地址空间内容，用户地址空间内容是独立的，而内核地址空间则是相同的，所以子进程对于用户地址空间内容的修改对于父进程是不可见的；除此之外，父子进程的当前工作目录是相同的，拥有相同且独立的打开文件列表。执行fork操作后，将分别返回到父进程和子进程中，父子进程可以分别独立的运行。子进程拥有指向其父进程PCB的指针。
			进程结束时会发起exit操作，这将释放自己所占用的部分资源，并将自己的所有子进程交给初始进程作为其子进程，如果有子进程已经进入ZOMBIE状态则唤醒初始进程对其处理，保存退出时的状态，然后进入ZOMBIE状态，唤醒并等待父进程对其进行进一步处理，ZOMBIE的进程无法再次运行。
			父进程可以通过wait操作等待它的某个子进程进入ZOMBIE，如果发现ZOMBIE子进程则回收其占用的剩余资源，在wait时，如果没有子进程退出则父进程将睡眠下去，直到某一个子进程退出。
			系统所创建的第一个可调度进程为uinit，后续所有进程均为该进程的子进程或者孙子进程，该进程将循环wait，回收那些已经ZOMBIE的子进程的资源，参考用户程序/进程构建及运行一节。
			每个进程都具有一个工作目录，在解析文件系统路径时如果没有指定该路径是绝对路径，则从当前进程的工作目录开始解析；
			
			与CPU相关的数据结构如下：
				GDT
				IDT
				TSS
				pgdir		scheduler线程的页目录虚拟地址
				scheduler的context指针
				cur_proc	当前运行在CPU上的proc，不包括scheduler，为空时表明没有运行的进程
			
			PCB_explain:
				pid			进程id
				name[]		数组，用于保存当前进程名字
				state		进程状态
				pgdir		进程页目录虚拟地址
				kstack		内核栈起始位置（不是内核栈esp位置）
				trapframe	指针，指向位于当前进程内核栈中的中断信息起始位置
				context		指针，指向位于当前进程内核栈中的内核线程上下文信息
				eflags_stack	保存进行pushcli/popcli之前的eflags值
				eflags_sp		上一次压入的eflags在eflags_stack中的位置
				channel		等待队列号，应该是内核地址空间中一个数据结构的地址
				cwd			指向当前工作目录的inode结构指针【待更新，建议初始时设置context.eflags开启中断，以便在forkret中对其进行初始化；或者在进入forkret之后再开启中断，然后再初始化该域】
				open_files[]	进程的打开文件指针列表
				size		从PROC_LOAD_ADDR开始的有效用户地址空间大小，不包括用户栈
				parent		父进程的PCB指针
				retval		退出时的状态值
				
				trapframe:
					eip/cs/eflags/esp/ss;	进程中断时被CPU压入的信息（存在特权级转换时esp/ss为有效值）
					trap_no/err_code;		中断程序和CPU共同负责压入
					gs/fs/es/ds;			进程被中断时需要保存的CPU寄存器
					edi/esi/ebp/_esp/ebx/edx/ecx/eax;
				context:
					eip/edi/esi/ebp/ebx/eflags;	进程的内核线程的上下文信息，在swtch函数中进行保存，由于是通过C函数调用该函数，所以不需要保存eax/ecx/edx，由于是在内核中切换，所以cs/ss/ds/es/fs/gs不需要保存，esp由context指针隐式的保存
					
			整体思路是：定义出一个进程所必需的数据结构；然后手动构造出第一个进程；再切换到该进程继续做剩余的系统工作。
			首先构造出一个PCB，在PCB中定义好进程的初始状态；然后将加载关键寄存器，使得当前执行的代码成为一个正在运行在内核空间的进程；通过特殊构造的内核栈，使得这个进程看起来是从用户空间进入内核的；然后通过通用的返回机制返回到用户空间中执行；
			
			测试进程的构建：
				将所有测试进程的代码和数据段都链接在内核结尾处，其LMA从之前段延续，VMA则设置为从0x0开始，使用特定链接器变量来指明各个测试进程的VMA；除了在内核空间中对该区域有映射外，还将该区域映射到从0x0开始的用户空间上，同时设置对应的PTE/PDE具有RW属性，使得能够在测试进程中对其数据进行读写；
			
			整个内核工作的流程是：
				BIOS初始化，将控制转入GRUB；
				GRUB加载内核、进入保护模式，将控制转入内核；
				boot1中设置初始页表，进入分页模式；
				boot2中取消低端虚拟地址0MB ~ SUPPORT_MEM_SIZE的映射
					设置CPU.pgdir，即scheduler线程的内核页目录
					设置CPU.cur_proc为NULL
					初始化GDT（包括在GDT中安装TSS描述符、用户模式的代码段和数据段描述符）
					初始化IDT，尚未注册任何中断处理函数
					初始化8259A，关闭除主片上与从片相连的IRline之外的所有IRline
					初始化8253PIT，初始频率为100（每秒产生100次时钟中断），打开8259A中对应的IMR位
					初始化vmm
					
					初始化PCB表
					
					调用用于构造第一个进程的函数，确保该进程RUNNABLE
					调用调度器函数，该进程是第一个RUNNABLE的进程，将被调度执行
					
					进行时钟中断处理测试
					进行多进程测试
						在两个进程轮转调度测试中，似乎由于时钟中断过于频繁，导致进程没有足够的运行时间，刚刚进入用户模式，连一条指令都没有执行就再次发生时钟中断，这种情况在bochs/virtualbox上有时会出现
						在virtualbox中单个进程进行测试时，不会出现#GP异常，而加入多个进程测试时会出现#GP异常，出现#GP异常之前，已经至少轮转调度了一次进程，eip指出异常发生在trapret的iretd处，错误代码指出GDT访问越界，此现象在bochs中却没有
						有时候频繁出现39号中断，有时仅出现几次
			需要提供的接口：
				构造第一个进程：
					调用函数分配PCB，该函数同时完成PCB中一部分信息的初始化；
					
					创建第一个进程的内核地址空间；
					调用函数，初始化第一个进程的用户地址空间；
					设置PCB.pgdir；
					所有PCB.trapframe成员清零；
					将PCB.trapframe.ss设置为引用用户模式数据段；
					将PCB.trapframe.esp设置用户栈栈顶位置；
					设置PCB.trapframe.eflags，开启中断，设置其IOPL为0，其余位为0或者保留值；
					设置PCB.trapframe.cs/eip使其指向用户空间中进程执行的起始位置；
					
					设置PCB.trapframe.gs/fs/es/ds，使其引用用户模式数据段；
					
					设置PCB.name为initcode；
					
					清空PCB.open_files中各个成员；
					
					设置PCB.size为第一个进程镜像大小（不包括用户栈）；
					
					设置PCB.parent为NULL；
					
					先将TSS所有成员清零，包括I/O映射基址
					将TSS.ss0设置为内核模式数据段描述符的选择子；
					将TSS.esp0设置为PCB.kstack的栈顶位置；
					加载TSS选择子到TR；
					
					设置PCB.state为RUNNABLE；
					
				创建一个当前进程的副本作为其子进程：
					成功将在系统中创建一个当前进程的副本进程为其子进程，父子进程在用户模式下的执行是连续的，在父进程中返回子进程的PID，在子进程中返回0；失败则返回-1；
					
					调用函数，分配一个PCB给子进程使用，结果保存为child；
					如果无PCB可用
						返回-1；
					将子进程的pid保存在pid中；
					调用函数，创建当前进程地址空间的一个副本，结果保存在child->pgdir中；
					如果child->pgdir为NULL
						调用函数，释放child的内核栈；
						关闭中断；
						调用函数，清零该PCB；
						将该PCB的状态置为UNUSED；
						恢复原先的中断状态；
						返回-1；
					设置child->parent，使得该进程为当前进程的子进程；
					将当前进程名作为child的进程名；
					将当前进程的trapframe复制到child的内核栈顶；
					复制当前进程的cwd引用，作为child的当前工作目录；
					复制当前进程的打开文件列表给child，使其共享相同的打开文件结构；
					将当前进程对应PCB.size作为child->size的值；
					更改child->tf->eax，使child从内核中返回后的值为0；
					
					关闭中断；
					将child的状态置为RUNNABLE；
					恢复原先的中断状态；
					返回pid；
				
					注意：
					在当前设计中，pid使用uint32_t类型保存，但是限制pid只能在int32_t所能表示最大值范围内；
				结束当前进程，保存退出状态以供父进程使用：
					ret: 退出状态值；
					成功后释放当前进程所占据的部分资源，并使其进入ZOMBIE状态，不可再次运行，失败则PANIC；
					
					将ret保存在当前进程对应的PCB中；
					调用函数，丢弃所有对打开文件结构的引用，清空打开文件指针列表；
					调用函数，丢弃对当前工作目录对应i结点的引用，清空该指针；
					调用函数，释放掉当前进程的用户地址空间内容，将PCB.size置为0；

					关闭中断；
					调用函数，通过父进程对应的PCB地址唤醒父进程；
					遍历PCB表
						如果发现一个有效PCB且该PCB对应进程为当前进程的子进程
							设置该子进程的父进程为初始进程；
							如果该子进程为ZOMBIE
								调用函数，通过初始进程对应的PCB地址唤醒初始进程；
					设置当前进程状态为ZOMBIE；
					调用函数，切换到scheduler进程，不再返回；
				
				等待子进程结束，并获取其退出状态：
					ret: 指向保存退出状态值的位置；
					如果有子进程结束则释放其所占据的剩余资源，返回其pid，并保存其退出状态到*ret中；如果所有子进程都尚未结束则睡眠下去直到某个子进程结束执行；如果没有子进程则返回-1；
					
					关闭中断；
					repeat处：
					设置havekids为0；
					遍历进程表，寻找其子进程；
						如果当前PCB无效，或者所对应进程不是当前进程的子进程
							跳过余下部分的处理，检查下一个PCB；
						设置havekids为1；
						如果当前进程的状态为ZOMBIE
							设置*ret为该子进程的返回值；
							设置pid为该子进程的pid；
							调用函数，释放该子进程的内核栈；
							调用函数，释放该子进程的分页结构（内核地址空间所映射的内存不会被释放）；
							调用函数，清零该子进程对应的PCB；
							将该PCB状态置为UNUSED；
							
							恢复原先的中断状态；
							返回pid；
					如果havekids为0
						说明没有子进程；
						恢复原先的中断状态；
						返回-1；
					调用函数，睡眠在当前进程对应的PCB上，等待某个子进程退出；
					被唤醒后，跳转到repeat处，再次检查子进程的状态；
					
				调度函数：
					暂时开启中断；
					关闭中断；
					使用proc变量从头遍历PCB表
						如果当前proc->state不为RUNNABLE
							跳过循环中剩余部分；
						切换到proc使用的分页结构中；
						重新设置CPU.TSS.esp0为proc的内核栈栈顶位置；
						设置proc->state为RUNNING；
						设置CPU.cur_proc为proc；
						调用swtch，将当前scheduler内核线程的上下文保存，切换到proc->context，此时proc对应的进程开始运行；
						从swtch返回后，表明已经回到scheduler线程中了；
						切换回scheduler线程的分页结构；
						清空CPU.cur_proc；
					返回，暂时的开关中断，再从头遍历PCB表；
				
				swtch例程（用于内核线程的上下文切换，应该从C中调用）：
					使用push，在当前内核线程栈中保存其上下文；
					更新当前PCB.context指针，使其指向栈上的内容；
					切换esp到新内核线程PCB.context，即切换到其内核栈上；
					使用pop，恢复新内核线程栈中保存的上下文；
					使用ret，返回到新内核线程中执行；

				分配PCB函数:
					关闭中断；
					从头遍历PCB表
						如果当前PCB.state为UNUSED的
							将当前PCB.state设置为NEWBORN；
							恢复原先的中断状态；
							设置当前PCB.pid为最小可用的pid；
							记录该PCB的地址到new_pcb中；
							跳出循环；
					如果没有找到一个UNUSED的PCB
						恢复原先的中断状态；
						返回NULL；
					
					清零eflags_stack，设置eflags_sp为嵌套次数最大值；
					初始化channel为NULL；
					初始化retval为0；
					分配一个清零过的内核栈，写入new_pcb->kstack；
					
					在这个内核栈中为trap frame留出空间；
					使new_pcb->trapframe指向这个trap frame；
					
					在内核栈中写入trapret的入口地址；
					
					在内核栈上构建context；
					使new_pcb->context指向这个context；
					清空context中所有成员；
					使context.cs/eip指向forkret的入口地址；
					设置context.eflags，开启中断，设置其IOPL为0，其余位为0或者保留值；
					返回new_pcb；
				
				分配PCB函数，但是只应该在进程不可使用pushcli/popcli时被使用【注意使用方式】
					函数执行逻辑等同于上述函数，但是没有考虑锁住PCB表！
					
					注意：在使用该函数时，要保证没有其他进程在使用PCB表；
				
				forkret函数：
					初始化第一个进程的当前工作目录为根目录；
					ret，使用特意压入内核栈上的eip返回到trapret中；
				
				trapret例程（该例程是alltraps中恢复中断线程现场信息的部分）：
					使用pop，恢复proc内核栈中的部分trap frame内容；
					使用iret，恢复cs/eip/eflags/ss/esp，从中断中返回；
					至此，proc从PCB.trapframe.cs/eip处开始执行；
				嵌套的关闭和开启中断
					参见daily_record.txt/20:58 2019/2/2
				睡眠（channel）：
					保存原先的中断状态，并关中断
						pushcli
					必须存在当前进程
						if(cpu.cur_proc == 0)
							PANIC
					在channel上睡眠
						cpu.cur_proc.channel = channel
						cpu.cur_proc.state = SLEEPING
					切换到scheduler
						swtch(&cpu.cur_proc.context, cpu.scheduler)
					被唤醒后
						cpu.cur_proc.channel = 0
					恢复原先的中断状态
						popcli
				唤醒（channel）：
					保存原先的中断状态，并关中断，当前调用进程必须可调度
						pushcli
					调用函数，在关闭中断的情况下唤醒在channel上的进程
					恢复原先的中断状态
						popcli
				已经关闭中断时的唤醒（channel）：
					遍历进程表，找出睡眠在channel上的进程，如果有则唤醒它
						for(pcb = &pcb_table[0]; pcb != &pcb_table[N]; pcb++)
							if pcb->state == SLEEPING && pcb->channel == channel
								pcb->state = RUNNABLE
				
				创建子进程【系统调用】：
					成功将在系统中创建一个当前进程的副本进程为其子进程，父子进程在用户模式下的执行是连续的，在父进程中返回子进程的PID，在子进程中返回0；失败则返回-1；
					调用函数，实现子进程的创建，并返回其返回值；
					
				结束当前进程【系统调用】：
					调用函数，获取用户栈中第0个4字节参数作为当前进程的退出状态，保存在retval中；
					如果失败则PANIC；
					调用函数，以retval为退出状态，结束当前进程；
				
				等待子进程退出【系统调用】：
					调用函数，获取用户栈中第0个4字节参数作为指针，保存在retval中；
					如果失败则PANIC；
					调用函数，等待子进程退出，并将其退出状态保存在retval指向的位置；
					返回上述函数的返回值；
				返回当前进程pid【系统调用】：
					返回pid；
				
			文件的组织结构：
				process.h: 定义CPU相关数据结构、trapframe结构、context结构、PCB结构、TSS结构；
						   提供与process相关的函数原型、拓展在其他文件中的CPU结构体变量定义范围；
				process.c: 提供与process相关的函数实现、定义与process管理相关的变量（CPU、PCB表）；
				process.asm: 提供与process相关的汇编例程；
				sys_proc.c: 封装与进程管理有关的系统调用；




						
	5.文件系统
		文件系统用于持久化存储、管理数据，并对资源的并发访问提供支持。
		文件系统在磁盘上的格式：
			sector 0(LBA28地址)		boot sector
			sector 1				super block(超级块)
			sector 2...n			disk inode bitmap
			sector n+1...m			block bitmap
			sector m+1...i			disk inodes
			sector i+1...			blocks
		每个扇区为512字节，每个block（块）亦为512字节，一一对应。
		
		超级块中包含了文件系统的元信息，其格式如下：
			block bitmap占用的块数，4字节；该bitmap用于记录文件系统中块的分配情况，boot sector、super block、disk inode bitmap以及block bitmap所占用的块不计入该位图内；
			
			disk inode bitmap占用的块数，4字节；该bitmap用于记录文件系统中磁盘i结点的分配情况，boot sector、super block、disk inode bitmap以及block bitmap所占用的块不计入该位图内；
			
			可用于分配的block总数，4字节；即block bitmap中有效位的个数；
			
			可用于分配的磁盘i结点总数，4字节；即disk inode bitmap中有效位的个数；
			
			磁盘i结点占用的块数，4字节；
			
		disk inode从0开始编号，disk inode bitmap的第一个bit对应第0个disk inode，依次类推；block从0开始编号，block bitmap的第一个bit对应第0个block，依次类推，第0个block视为无效；如果两个bitmap中有些bit是无效的，则在构建文件系统时就应该将这些bit置位。
		若已知bitmap中某bit相对于该bitmap开头的偏移offset，则可根据如下方法计算该bit对应的block/inode的编号以及所在sector号：
			block编号=offset
			block所在sector号 = 2 + 两个bitmap所占sector数 + disk inodes所占用的sector数 + offset
			disk inodes所占用的sector数 = (可用于分配的磁盘i结点总数 * sizeof(disk inode)) % sizeof(block) ? (可用于分配的磁盘i结点总数 * sizeof(disk inode) / sizeof(block) + 1)
			: (可用于分配的磁盘i结点总数 * sizeof(disk inode) / sizeof(block))
			磁盘i结点编号=offset
			disk inode所在sector号 = 2 + 两个bitmap所占sector数 + offset/(sizeof(block)/sizeof(disk inode))
			disk inode所在sector中的偏移（即还需要偏移多少个inode） = offset % (sizeof(block)/sizeof(disk inode))
			
		本文件系统分为块分配层、i结点层、目录层、路径层、打开文件层、文件描述符层来实现。块分配层负责分配、回收数据块；i结点层提供无名文件，每一个这样的文件由一个i结点和系列数据块组成；目录层在i结点层的基础上实现目录，即目录只是一种特殊的无名文件；路径层实现路径与i结点的映射；打开文件层维护文件使用过程的中的信息，且为文件系统管理的资源提供一层统一的抽象；文件描述符层则帮助隐藏了实现细节；
		
		磁盘i结点用于记录文件的信息，每一个文件均有一个磁盘i结点和一些数据块组成，其格式如下：
			类型，2字节；表示该磁盘i结点代表的是目录、普通文件还是设备（字符设备、块设备）；目前不在磁盘i结点中记载文件的读写属性，默认可读可写，亦不做可执行权限检查；
			主设备号、从设备号，各2字节；当该磁盘i结点表示设备文件时，使用这两个字段表示何种设备，主设备号指定设备类型而从设备号指定同一类型的某个设备；由于在buf cache中使用的dev为int32类型，而这里指定的设备号均为uint32类型，所以需要注意合法的设备号范围；
			
			链接计数，2字节；记录有多少个目录项指向了该磁盘i结点；
			
			文件大小，4字节；记录文件内容长度，以字节为单位，对设备文件没有定义；
			记录数据块号的数组，每个元素4字节，共13个元素；0-11号元素为直接索引，即直接可以使用该索引号找到目标数据块，12号为间接索引，需要先通过该间接索引号找到一个间接索引块（数据块），再从该间接索引块中读取一个索引号，找到目标数据块；由于0号block不使用，所以索引0视为无效，便于对数组进行初始化。
			
		磁盘i结点应该是2的次幂个字节，这样不会跨扇区。
		在内核中构建了内存i结点，其内容为磁盘i结点的副本并添加了一些控制信息，其结构如下：
			设备号，4字节，表示该i结点是从哪个设备上读出的；
			i结点号，4字节，为disk inode bitmap中对应bit的偏移量；
			引用计数，4字节，表示有多少对该i结点的引用（指针）；
			标志位，4字节，表示该i结点的使用状态；为0表示未设置任何标志；
				BUSY，表示已经被某个进程锁住；
				VALID，表示其内容有效（指磁盘i结点内容副本）；
			磁盘i结点内容副本；
		同时，内核提供一个inode cache（由多个内存i结点结构组成，目前暂设50个）；类似于buf cache，inode cache用于同步多进程对inode的访问：inode可以被多个进程同时引用，但是同一时间，只能有一个进程锁住一个inode为自己使用（BUSY），使用时应该避免在锁住一个inode后再想锁住另一个inode，这样可能导致死锁。
		
		inode cache只缓存正在被引用的inode，若cache中某个inode引用计数为0，表明该inode结构为空的，即可重新装填新的磁盘i结点；一个磁盘i结点同时只能在cache中拥有一个副本；当引用计数大于0时，其设备号、i结点号是有效的，当标志为VALID时，该inode结构中拥有对应磁盘i结点有效的内容副本。
		
		使用新的磁盘i结点前需要进行分配，分配到的磁盘i结点将与inode cache中的一个inode对应起来且其引用计数将加1，进程将获得该inode的指针；如果进程需要对该磁盘i结点进行修改，则需要对该inode（或者说是该磁盘i结点）上锁（BUSY）；上锁中若发现该inode数据无效（UN-VALID），则读取磁盘i结点数据到该inode中；进程修改后应该主动同步该inode的内容到磁盘上；进程使用完毕后应该解锁该inode，以便其他进程使用，解锁仍然保持进程对该inode的引用；若进程不再需要该inode，则应该丢弃该inode的引用，丢弃过程中会检查该inode的引用计数，倘若引用计数为0，则这个inode将被标明空闲，若同时其链接计数也为0，则还需要在磁盘上释放该磁盘i结点和所关联的数据块。
		若进程想要使用的某个磁盘i结点已经缓存在cache中了，则可以直接返回对应inode的指针；如果没有缓存在cache中，则会从中找一个空闲的inode结构来缓存该磁盘i结点。
		
		在inode层实现了统一的读写函数，便于访问inode表示的资源（目录、设备、普通文件）。
		
		用户进程可以通过stat结构获取inode的信息，其定义如下：
			inode所在设备号；
			inode号；
			inode类型，目录、普通文件、设备；
			inode所表示的设备号（主、从设备号，仅当inode表示设备时有效）；
			指向该inode的链接数；
			inode所表示的普通文件大小（字节单位）；
		应该通过正常的途径获取i结点编号，在多进程竞争的情况下直接使用i结点编号（比如直接通过指定设备号和i结点号来获取inode指针）有风险，可能会破坏文件系统的结构或者导致死锁。
		在当前的设计中，I/O设备也被抽象为一个设备文件，可以通过一个i结点文件来对它进行操纵。i结点的类型、主从设备号用来确定是其所表示的是哪个设备。
		针对字符类设备，系统维护有一个设备表，每一个设备均具有一个对应的表项；表项中则注册有用于操纵该设备的函数；可通过主设备号索引到该设备在设备表中的表项。目前针对字符类设备仅支持读写两种操作；且仅支持1个字符类设备。
		字符类设备表的表项定义如下：
			读函数：
				从设备读取n个字节到缓冲区buf中，允许读取的字节数少于n；成功返回实际读取的字节数，失败返回-1；
			写函数：
				将缓冲区buf中的n个字节写入设备，如果写入失败则返回-1，否则应该返回实际写入的字节数；
		目录也是通过i结点来构建的，若i结点所表示的资源内容由若干个目录项组成，则称该i结点表示一个目录（DIR_INODE）；目录项包括一个i结点号和与之关联的名字，由于可以有多个目录项指向同一个i结点（链接计数），所以一个i结点可以有多个关联的名字；一个目录项的名字最长为28个字节，如果少于28个字节，则在该名字的后面添加一个NUL字符表示结尾；一个空名字的目录项被视为空的（目录项的名字的第一个字符为NUL）；一个目录文件中可以包含多个指向子目录或者文件的目录项，但这些目录项不能同名；每一个目录中均包含名字为“.”和“..”的特殊目录项，分别指向当前目录和当前目录的上层目录；根目录中的“..”则指向其自身。
		当目录中仅含有“.”和“..”这两个目录项时，则认为该目录是空的。
		用于保存系统启动所必需文件的文件系统被称为根文件系统，其所在设备被称为根设备，目前由于仅支持一个IDE硬盘，所以根设备号为0。
		设定根目录所在i结点号为0。
		文件系统中通过路径来指定所要访问的资源，路径名即是资源名；路径名由分隔符'/'和元素构成，元素指目录名或者文件名；设计中不对路径的最大层次做限制（层次指路径中元素的个数）。
		以'/'开头的路径被称为绝对路径，对这类路径的解析总是从根目录开始；非'/'开头的路径被称为相对路径，其解析则是从进程当前工作目录开始。
		路径中一个或者多个连续的'/'均被视为一个'/'，作为路径中元素的分隔符；其余的连续字符则构成路径中的多个元素，以分隔符分隔开来；元素长度（组成元素的字符个数）不能超过目录项名字的最大长度，在解析过程中超过部分被忽略；除路径最后一个元素外，其余元素必须是目录名。
		
		例如：
			“//ab///c/d//”为绝对路径，等同于“/a/c/d”，这里假设最长目录名为一个字符；
			“./aa//c/d”为相对路径，等同于“./a/c/d”，这里假设最长目录名为一个字符；
			“./a/../c”为相对路径，等同于“./c”，这里假设最长目录名为一个字符；
		针对每一个打开的inode（目录、普通文件、设备）或者管道，都有一个open_file_struct与之对应，除了inode信息，还记录文件或管道在使用过程中的一些信息，比如文件偏移量、文件的操作模式（读写）、多少个文件描述符引用了这个结构，这些信息被视为使用过程中的信息；其具体结构定义如下：
			类型，该打开文件结构所表示的资源类型，目前支持两类：inode文件、管道
			引用计数，2字节，这个结构的文件描述符引用计数；
			操作模式，4字节，比如只读、只写、读写；
			inode指针，所描述的目标i结点；
			管道指针，所描述的管道对象；
			文件偏移，4字节，相对于文件开头的偏移量，读、写从这个位置开始，目前只对目录和普通文件有意义；
		内核维护一个全局的open_file_struct列表，表示当前系统中所有正在使用中的open_file_struct；可以有多个open_file_struct关联同一个inode或者管道，这样就允许存在多个inode使用实例；每个进程都维护有一个open_file_struct指针列表，文件描述符是这个指针列表的索引，当文件描述符对应的指针不为NULL，则称这个文件描述符引用了一个open_file_struct，而当其为NULL时，表示这个文件描述符可被重新使用；一个进程可以有多个文件描述符引用同一个open_file_struct，也可以不同进程间同时拥有引用同一个open_file_struct的文件描述符；open_file_struct的引用计数记录当前被引用的次数，当引用计数为0时，表示该结构空闲可被回收利用。
		目前暂定内核支持最大同时使用64个open_file_struct，每个进程能够同时拥有最多20个open_file_struct结构引用；
		open_file_struct在使用中，其类型、操作模式、inode指针、管道指针均不会再改变，所以设计上没有在给这个结构添加类似inode的锁标志；当需要修改引用计数时则采取暂时关闭中断的方式保证操作的原子性；对于文件偏移，可能存在多个进程共享同一个open_file_struct时，同时操作文件偏移；对于读、写操作而言，在修改文件偏移时需要先获得inode锁，以保证同时只有一个进程进行操作，同时对一个文件写并不会覆盖各自的文件，但是写的顺序是不被保证的，因此写的结果可能是交织的（在一个写操作的过程中插入了另一个写操作）；对于文件偏移定位（比如linux中的lseek）这种操作，则需要进程自身提供同步的方式以保证其正确性；
		
		块分配层：
			block bitmap中的每一个bit代表数据区中一个block的使用情况（置位表示已使用，否则表示空闲），其偏移量即为block的编号。
			提供的功能：
				读取指定块设备上的文件系统的超级块；
				清空指定block中的内容；
				在指定块设备上的文件系统中分配空闲块，返回其编号：
					读取文件系统的super block；
					根据super block的信息，搜索block bitmap，寻找空闲位；
					设置该空闲位，更新到磁盘；
					清零该空闲位对应的block，然后返回该block的编号；
					未找到则PANIC；
				在指定块设备上的文件系统上回收指定block：
					读取文件系统的super block；
					根据super block的信息，搜索block bitmap，寻找该block对应的位；
					如果该位被置位则PANIC；
					重置该位，更新到磁盘；

			文件的组织结构：
				block.h：提供块分配函数接口和超级块结构定义；
				block.c：提供块分配函数实现；
				fs.h：提供文件系统相关的结构定义；
		
		i结点层：
			类似于block bitmap，disk inode bitmap中的每一个bit代表一个disk inode的使用情况，其偏移量为i结点的编号。
			在指定设备的文件系统上分配磁盘i结点，并返回其对应的内存inode的引用（设备号dev）：
				读取dev上的文件系统的超级块；
				根据超级块定位到disk inode bitmap；
				遍历disk inode bitmap所占据的block；
					如果发现一个空闲bit
						置位，写回磁盘；
						释放对block的锁；
						根据dev和i结点编号，调用函数在inode cache中查找或者新分配一个inode结构，并返回其指针；
					释放对block的锁；
				查找失败，PANIC；
			
			在指定设备的文件系统上释放磁盘i结点（设备号dev，i结点编号）：
				读取dev上的文件系统的超级块；
				根据超级块、i结点编号定位到disk inode bitmap中的某个block；
				读取并锁住该block；
				如果该block中该i结点对应的bit没有置位则PANIC；
				清除该block中该i结点对应的bit；
				写回设备；
				释放该block；
			
			在inode cache中查找或者新分配一个对应于指定设备上某个i结点的inode结构（设备号，i结点编号）：
				关闭中断；
				遍历inode cache
					如果找到设备号、i结点编号对应的inode结构且其引用计数大于0
						说明该磁盘i结点已被cache；
						增加其引用计数；
						恢复原先的中断状态；
						返回其指针；
					记录找到的第一个引用计数为0的inode结构；
				如果找到一个引用计数为0的inode结构
					设置其设备号和i结点编号；
					设置引用计数为1；
					清空标志位；
					恢复原先的中断状态；
					返回指针；
				否则PANIC
				
				注意：这里没有检查设备号和i结点编号
			
			对inode上锁，需要时从磁盘获取该inode对应的数据（inode指针）：
				如果inode引用计数小于1，则PANIC；
				
				关闭中断；
				如果inode为BUSY的
					睡眠在该inode上，等待被唤醒；
					返回继续检查inode的状态；
				在该inode的状态中添加BUSY标志；
				恢复原先的中断状态；
				如果inode不是VALID的
					读取并锁住inode对应磁盘i结点所在block；
					将block中对应的数据复制到inode中；
					释放block上的锁；
					在inode状态中添加VALID标志；
			
			将inode中的磁盘i结点内容副本写入磁盘（inode指针）：
				如果inode引用计数小于1或者是UN-BUSY的，则PANIC；
				
				读取inode所在dev上的文件系统的超级块；
				根据超级块定位到inode所在的block；
				读取并锁住block；
				将inode更新到block上相应位置；
				写回block；
				释放该block；
				
				注意：这里在锁住inode的同时还请求锁住超级块，但是由于我们在获得超级块后立即将其释放，所以目前来看不会造成死锁，下一步的做法可以考虑在第一个进程从forkret返回时，调用函数将超级块读入，然后所有进程共享这一个副本，只读入一次即可；或者是提供一个忙等待的驱动接口，在内核初始化时直接读取文件系统的超级块；
			
			解锁inode（inode指针）：
				如果inode是UN-BUSY的或者其引用计数小于1，则PANIC；
				
				清除inode中的BUSY位；
				唤醒在该inode上睡眠的进程；
				
			丢弃inode的引用（inode指针）：
				关闭中断；
				如果引用计数小于1，则PANIC；
				
				如果引用计数为1、VALID且链接计数为0
					如果inode是BUSY的，说明在尝试未解锁之前丢弃引用；
						PANIC；
					在inode状态中添加BUSY标志；（此句不删除，因为后一个函数调用要求inode是BUSY的）
					调用函数释放与inode关联的所有数据块和间接索引块（如果有的话）；
					调用函数释放磁盘i结点；
					清空标志位；（保险起见不删除此句）
				引用计数减一；
				恢复原先的中断状态；
				
				注意：
				1.在该函数中虽然关闭了中断，但期间进程可能会睡眠（比如等待硬件完成操作），这样可能破坏先前的假设；比如：在释放磁盘i结点时，可能在需要等待设备完成操作而睡眠，这时如果某个进程试图分配同一个磁盘i结点（因为此时inode bitmap已经写回了），在分配成功后就会试图获取inode结构的引用，就会找到当前正在处理的这个inode（因为其设备号、i结点号相同且有引用计数），这样就出现了暂时的不一致状态，直到这个进程试图锁住这个inode结构时，才能从这个不一致状态中恢复过来。
				更新：上述情况实际不会发生，因为在睡眠时仍锁住了inode bitmap中对应的block，而另外的进程只能等待其解锁；而当其被唤醒运行后，又是处于关中断的状态下，随后释放inode bitmap中block的锁，虽然能够唤醒这些进程，但却没法被调度，直到上述函数执行完毕；所以上述函数锁住inode是没有必要的，另外也无需像xv6一样唤醒在等待该inode的进程。
				2.如果进程在释放与inode关联的block时睡眠了，其他进程能够运行，但是一般不会访问这个正在丢弃的inode，因为该inode引用计数为1、链接计数为0；除了根节点，一般来说进程不会直接通过i结点号进行访问；而根节点是关键结点，链接计数不应该为0。
				
			释放与inode相关联的所有数据块，包括间接索引块（inode指针）：
				如果引用计数小于1或者是UN-BUSY的，则PANIC；
				
				读取inode所在dev上的文件系统的超级块；
				遍历inode中所有的直接索引
					如果该直接索引有效（即在1~block编号范围之内，下同）
						调用函数释放该索引指定的数据块；
						设置该索引为NAVL_BLK_NUM；
				如果inode中间接索引有效
					读取并锁住该间接索引块；
					遍历间接索引块上的索引号
						如果该索引号有效
							调用函数释放该索引指定的数据块；
					释放间接索引块上的锁；
					调用函数释放间接索引块；
					设置间接索引号为NAVL_BLK_NUM；
				设置inode的文件大小域为0；
				调用函数，将inode中的磁盘i结点内容副本写入磁盘；
				
				注意：这里进程可能会同时拥有两种或三种锁：i结点锁、索引所在bitmap中的block的锁、间接索引块所在block的锁；由于最后一种锁应该是在获得i结点锁之后才可能获得的锁，而且通常不会有进程先持有bitmap中的锁然后再试图获得i结点的锁，所以该函数中应该不会出现死锁风险。
				
			复制一个inode结构的引用，返回复制后的引用（inode指针）：
				关闭中断；
				如果inode引用计数小于1则PANIC；
				增加inode的引用计数；
				恢复原先的中断状态；
			
				注意：这种设计是为便于实现ip1 = dup(ip)这种用法
			获取inode映射的第n个block的对应的扇区编号，如果该位置尚未映射block则新分配一个清零过的block并建立映射关系（inode指针，n）：
				//如果inode引用计数小于1或者是UN-BUSY的，则PANIC；（由于该函数用于下面读写i结点的函数，在这两个函数中已经检查过，故不再检查）
				假设bnum为所找到的block编号；
				
				如果n在直接索引范围内
					令bnum为n对应的索引；
					如果bnum无效
						调用函数分配一个清空过的block，并将其记录在地址数组中n对应的位置；
						令bnum为刚刚分配的block号；
						调用函数将i结点内容更新到磁盘；
					返回bnum对应的扇区编号；
				
				此时说明n不在直接索引范围内；
				令n为n减去最大直接索引个数（12）后的值，即n为间接索引块中的位置偏移；
				如果n在间接索引范围内
					如果间接索引块的索引无效
						调用函数分配一个清空过的block，并将其记录在地址数组中间接索引块对应的位置；
						调用函数将i结点内容更新到磁盘；
					读取并锁住间接索引块；
					令bnum为n对应的索引；
					如果bnum无效
						调用函数分配一个清空过的block，并将其记录在间接索引块中n对应的位置；
						令bnum为刚刚分配的block号；
						写回间接索引块；
					释放间接索引块上的锁；
					返回bnum对应的扇区编号；
					
				此时说明n超出了最大索引范围，PANIC；
						
			从inode的特定偏移处读取指定数量字节到缓存区中，返回实际读取字节数（inode指针ip，偏移量off，字节数n，缓存区地址dst）：
				定义函数min(a, b)返回值为a/b中的最小值；
				如果inode引用计数小于1或者是UN-BUSY的，则PANIC；
				如果inode表示字符设备
					调用相关的设备读函数并返回其返回值；
				否则如果inode表示块设备
					PANIC；
				
				if off > ip->size or off+n < off
					return -1
				if off + n > ip->size
					n = ip->size - off
				m = n
				
				for(; n > 0; n -= min, off += min)
					buf = acquire_buf(ip->dev, sector_num(bmap(ip, off/BLOCK_SIZE)))
					min = min(n, BLOCK_SIZE - off%BLOCK_SIZE)
					memmov(dst, &buf->data[off%BLOCK_SIZE], min)
					dst += min
					release_buf(buf)
				return m
				
				注意：
					读取出错时（比如off/n有误）返回-1；对于设备的读操作，参照相关设备的说明。
					在磁盘i结点结构定义中size成员为无符号的，但实际受限于设计，最大文件仅为70KB，这里返回值使用有符号类型（为能区别错误值），但仍能满足使用，使用时需要注意。
					对块设备的读函数尚未实现。
				
			向inode的特定偏移处写入缓存区中的指定数量字节，返回实际写入字节数（inode指针，偏移量，字节数，缓存区地址）：
				如果inode引用计数小于1或者是UN-BUSY的，则PANIC；
				如果inode表示字符设备
					则调用相关的设备写函数；
				否则如果inode表示块设备
					PANIC；
				if off > MAX_SIZE or off+n < off
					return -1
				if off + n > MAX_SIZE
					return -1
				m = n
				for(; n > 0; n -= min, off += min)
					buf = acquire_buf(ip->dev, sector_num(bmap(ip, off/BLOCK_SIZE)))
					min = min(n, BLOCK_SIZE - off%BLOCK_SIZE)
					memmov(&buf->data[off%BLOCK_SIZE], src, min)
					src += min
					write_buf(buf)
					release_buf(buf)
				if n > 0 && ip.size < off //要发生实际的写入且写入后off超出了当前文件大小才对当前文件大小进行更新。
					ip.size = off
					调用函数更新inode结构内容到磁盘；
				return m
				
				注意：
					当写入出错时（比如off/n有误、写入数据会超出最大文件大小）返回-1；对于设备的写操作，参照相关设备的说明。
					在磁盘i结点结构定义中size成员为无符号的，但实际受限于设计，最大文件仅为70KB，这里返回值使用有符号类型（为能区别错误值），但仍能满足使用，使用时需要注意。
					对于块设备的写尚未实现；
				
			用户进程读取inode的信息（inode指针，stat指针）：
				如果inode引用计数小于1或者是UN-BUSY的，则PANIC；
				将inode结构中的信息复制到stat结构中；
				
			文件的组织结构：
				fs.h: 提供文件系统相关的常量、宏、数据结构定义；
				inode.c: 提供i结点层的函数实现；
				inode.h：提供i结点层接口的声明；
				stat.h: 提供stat结构定义；
		
		目录/路径层：
			在指定目录文件中查找具有特定名字的目录项，并返回其对应i结点的inode结构指针，该inode结构未被上锁，如果有必要，将设置其偏移量（目录i结点指针dir_ip, 指定名字name，该name对应目录项相对该文件开头的偏移量off指针）：
				如果dir_ip未被锁住或者不指向目录文件，则PANIC；
				
				调用i结点读取函数，从dir_ip开头处开始遍历所有目录项
					如果目录项为空，则跳过该目录项；
					如果目录项名字和name匹配
						如果需要记录偏移量，则写入off中；
						调用函数，获取其对应i结点的inode结构指针，并返回该指针；
				返回NULL；
			
			在指定目录文件中添加一个目录项（目录i结点指针dir_ip，指定名字name，对应i结点编号）：
				如果dir_ip未被锁住或者不指向目录文件，则PANIC；
				
				调用函数查找dir_ip中是否已经有同名目录项存在
				如果是
					丢弃上述函数返回的inode结构引用；
					返回-1；
				从dir_ip开头处开始遍历所有目录项
					如果目录项为空
						记录当前目录项偏移量，退出循环；
				使用name和对应i结点编号构建新的目录项；
				调用i结点写入函数，从偏移量处写入新的目录项；
				返回0；
				
				注意：要保证所提供的i结点编号是有效的，本函数不做检查。
			
			解析路径中下一个元素到elem中，返回下一次解析的位置或者NULL（路径path，元素elem，最后一个元素类型last_elem）：
				跳过开头连续的'/'字符；
				复制非'/'字符到elem中，复制长度由最大目录项名字长度、元素结束位置中的最小值来决定；
				如果没有解析出任何元素
					返回NULL
				否则
					如果所找到的元素没有达到最大目录项名字长度，则在所找到元素后面添加一个'\0'；
				跳过超出最大目录项名字长度部分的字符（如果有的话），直到遇到'/'或者'\0'；
				如果当前字符为'\0'
					说明这是最后一个元素，且不以'/'结尾；
					设置last_elem为2；
				否则
					跳过接下来连续的'/'字符（如果有的话）；
					如果当前字符为'\0'
						说明这是最后一个元素，且以'/'结尾；
						设置last_elem为1；
					否则
						说明这不是最后一个元素；
						设置last_elem为0；
				返回当前停止解析的位置；
				
				注意：
				当该函数没能解析出元素时返回NULL，否则会将解析出的元素名保存在elem中（elem必须能够容纳最大目录项名字长度），并且返回下一次开始解析的位置；
				如果解析出的元素是最后一个元素则last_elem被设置为大于0的值（以'/'结尾则设置为1，否则为2），否则被置为0；
			
			获取路径中最后一个元素复制到elem中，成功返回大于0的值（以'/'结尾则为1，否则为2）且elem中将包含最后一个元素的值，失败返回-1（指定路径path，最后一个元素写入的位置elem）：
				调用函数，解析path中第一个元素到elem中，并将返回结果保存在path中；
					如果没有元素可解析
						返回-1；
					如果该元素是最后一个元素
						返回最后一个元素类型值；
			
				注意：
				elem必须能够容纳最大目录项名字长度；
			解析路径，返回该路径指定对象的inode结构指针或者其父目录对应的inode结构指针，未锁住该i结点，如果是针对其父目录，同时如果name不为NULL则还将该路径指定对象的名字复制到name中（路径path，解析到父目录停止stop_at_parent，最后一个元素名字name）：
				如果是绝对路径（路径以“/”开头）
					获取根文件系统中根目录对应的inode结构指针ip；
				否则
					调用函数，复制进程当前工作目录对应的inode结构指针到ip中；
				循环调用函数解析path中的元素并复制到elem中，解析完毕则退出循环
					读取并锁住ip；
					如果ip并不是目录
						解锁并丢弃ip这个引用；
						返回NULL；
					如果指定stop_at_parent，且elem已经是最后一个元素
						解锁ip；
						将elem复制到name中；
						返回ip这个引用；
					调用函数在ip中查找名为elem的目录项；
					如果不存在
						解锁并丢弃ip这个引用；
						返回NULL；
					解锁并丢弃ip这个引用；
					令ip指向elem对应目录项的inode结构；
				
				如果指定stop_at_parent（此时说明是在解析"/"的父目录）
					丢弃ip这个引用；
					返回NULL；
				
				如果path中最后一个元素以'/'结尾，说明path指定对象应该是目录
					读取并锁住ip；
					如果ip并不是目录
						解锁并丢弃ip这个引用；
						返回NULL；
					解锁ip；
				返回ip这个引用；
				
				注意：
				对"/"路径查找其父目录，会返回NULL，以防止'/'出现在目录项名中；
				如果仅查找路径指定对象的父目录，则不检查路径指定对象是否存在；

			检查指定目录是否为空目录，为空则返回1，否则返回0（目录i结点指针dir_ip）：
				跳过头两个目录项（./..），遍历该目录文件
					如果发现某个目录项不为空
						返回0；
				返回1；
			文件的组织结构：
				path.c：目录操作函数的实现
				path.h：目录操作接口的声明
				fs.h：提供目录结构定义和其他需要的接口、结构、常量等定义
			
		打开文件/文件描述符层：
			从全局open_file_struct列表中分配一个空闲结构以供使用，返回结构指针，其引用计数将置为1，其ip/pipe指针置为NULL，type置为0：
				关闭中断；
				遍历全局open_file_struct列表
					如果找到一个引用计数为0的结构
						将其引用计数置为1；
						将其ip指针置为NULL；
						将其pipe指针置为NULL；
						将其type置为0，不代表任何一种资源；
						恢复原先的中断状态；
						返回该结构指针；
				没有找到空闲的结构，PANIC；
				
				注意：这个函数没有设置结构内容，需调用者处理；
			为当前进程分配一个最小未被使用的文件描述符，并使之引用一个打开文件结构，成功返回所分配的文件描述符，失败返回-1（结构引用指针fp）：
				从头遍历当前进程的打开文件指针表
					如果找到一个表项为NULL
						令这个表项指向fp引用的结构；
						返回该表项的索引；
				说明该进程已经达到所允许同时使用文件描述符的上限，返回-1；
				
			丢弃一个open_file_struct结构的引用，必要时丢弃结构中对inode的引用或者关闭管道（结构引用指针fp）：
				关闭中断；
				如果fp引用结构引用计数小于1
					说明这个引用无效，PANIC；
				将fp所引用结构的引用计数减一；
				如果剩余引用计数大于0
					恢复原先的中断状态；
					返回；
				将这个结构内容复制到一个临时副本中，以尽快释放该结构为其他进程使用；
				保险起见，将这个结构中对inode和管道的引用置为NULL；
				恢复原先的中断状态；
				
				如果副本中存在对管道的引用（不为NULL）
					调用函数，关闭管道的这一端口，可能会释放掉这个管道；
				否则如果副本中存在对inode的引用（不为NULL）
					调用函数，释放这个inode引用，可能会删除这个i结点文件；
				
			复制一个open_file_struct的引用，增加其引用计数（结构引用指针fp）：
				关闭中断；
				如果fp引用结构引用计数小于1
					说明这个引用无效，PANIC；
				将引用计数加1；
				恢复原先的中断状态；
				返回fp；
			在一个open_file_struct结构上从当前文件偏移处开始读取最多n个字节到buf中，成功文件偏移量增加实际读取字节数，并返回实际读取字节数，失败返回-1，不修改文件偏移量；如果所表示的是管道则其行为取决于管道的定义（结构引用指针fp，缓冲区起始地址buf，读取字节数n）：
				如果fp引用结构引用计数小于1
					说明这个引用无效，PANIC（尽管这里没有关闭中断，但仍可能检查出一些错误）；
				如果fp不可读（操作模式检查不可读）
					返回-1；
				
				如果fp引用的是管道
					如果引用为NULL，PANIC；
					调用函数，从管道中读取n个字节到buf中，返回该函数的返回值；
				否则如果fp引用的是inode
					如果引用为NULL，PANIC；
					锁住fd引用结构中的inode；
					调用函数，从inode中文件偏移量处读取n个字节到buf中，并保存返回值；
					如果返回值大于0
						将当前文件偏移量偏移实际读取的字节数；
					解锁fd引用结构中的inode；
					返回上述返回值；
				否则
					PANIC；
			在一个open_file_struct结构上从当前文件偏移处开始写入从buf开始的n个字节，成功返回写入字节数n，文件偏移量增加n个字节，失败返回-1，不修改文件偏移量；如果所表示的是管道则其行为取决于管道的定义（结构引用指针fp，缓冲区起始地址buf，写入字节数n）：
				如果fp引用结构引用计数小于1
					说明这个引用无效，PANIC（尽管这里没有关闭中断，但仍可能检查出一些错误）；
				如果fp不可写（操作模式检查不可写）
					返回-1；
					
				如果fp引用的是管道
					如果引用为NULL，PANIC；
					调用函数，将buf中的n个字节写入管道，返回该函数的返回值；
				否则如果fp引用的是inode
					如果引用为NULL，PANIC；
					锁住fd引用结构中的inode；
					调用函数，在inode文件中当前文件偏移量处写入从buf开始的n个字节，并保存返回值；
					如果返回值等于n
						将当前文件偏移量增加实际写入的字节数；
					解锁fd引用结构中的inode；
					返回上述返回值；
				否则PANIC；
				
			读取与open_file_struct关联的i结点信息到stat结构中，如果所表示的不是i结点，则返回-1，否则返回0（结构引用指针fp，stat结构指针st）：
				如果fp引用结构引用计数小于1
					说明这个引用无效，PANIC（尽管这里没有关闭中断，但仍可能检查出一些错误）；
				如果fp表示的不是i结点
					返回-1；
				如果i结点引用为NULL，PANIC；
				锁住fd引用结构中的inode；
				调用函数，将inode中信息记录在st指向结构中；
				解锁fd引用结构中的inode；
				返回0；
				
			文件的组织结构：
				file.c/file.h: 这一层的函数实现以及相关结构声明；
				fs.h：提供文件系统相关的结构、常量等定义；
				stat.h: 提供stat结构定义；
				
		文件系统接口支持函数：
			创建一条指向某个文件的路径：
				接受参数：
					oldpath指向被链接的文件（不能是目录文件）
					newpath是一条新的路径，这条路径最终将指向oldpath指向的文件
				成功返回0，失败返回-1；
				
				如果oldpath中某个应该是目录的部分不存在或者不是目录，操作失败，返回-1；
				如果oldpath指向的是目录文件，操作失败，返回-1；
				如果newpath已经存在，newpath指向对象不会被覆盖，操作失败，返回-1；
				如果newpath中某个应该是目录的部分不存在或者不是目录，操作失败，返回-1；
				其他的操作失败，也会返回-1；
				
				调用函数，对oldpath进行解析，解析结果保存在oldip中；
				如果解析失败
					返回-1；
				解析newpath指向对象的父目录，解析结果保存在dp中，并保存最后一个元素名字到name中；
				如果解析失败
					释放oldip；
					返回-1；
					
				锁住oldip；
				如果oldip指向的是目录文件
					解锁并丢弃oldip；
					丢弃dp；
					返回-1；
				如果oldip->link_num已达到最大值
					PANIC；
				将oldip->link_num增加1；
				写回oldip；
				解锁oldip；
				
				锁住dp；
				调用函数，在dp中添加目录项，名字为name，i结点号为oldip->inum；
				如果添加失败
					解锁并丢弃dp；
					锁住oldip；
					将oldip->link_num减去1；
					写回oldip；
					解锁并丢弃oldip；
					返回-1；
				解锁并丢弃dp；
				返回0；
				
				
				注意：
				“如果oldpath所指向的文件和newpath所指向对象的父目录不在同一个文件系统上，操作失败，返回-1；”这条暂不实现，因为对多文件系统支持不完善；
			删除指定路径，可能删除这个路径指定的文件：
				接受参数：
					指定要删除的路径path；
				成功返回0， 失败返回-1；
				
				如果path指定对象不存在，操作失败，返回-1；
				如果path中某个应该是目录的部分不存在或者不是目录，操作失败，返回-1；
				如果path指定“/”目录，操作失败，返回-1；
				如果path指定的是./..这两个目录项，操作失败，返回-1；
				如果path指定对象或者其父目录链接计数为0，PANIC；
				如果path指定的是目录文件，且目录文件不为空，操作失败，返回-1；
				
				调用函数，解析path指定对象对应的父目录对应inode到dp中，并将最后一个元素名字保存在name中；
				如果解析失败
					返回-1；
				锁住dp；
				如果dp->link_num为0
					PANIC；
				如果name为.或者..
					解锁并丢弃dp；
					返回-1；
				调用函数，在dp下查找name这个目录项，结果保存在ip中，偏移保存在off中；
				如果name不存在
					解锁并丢弃dp；
					返回-1；
				解锁dp；
				
				锁住ip；
				如果ip->link_num为0
					PANIC；
				如果ip指向的是目录，且这个目录不为空
					解锁并丢弃ip；
					丢弃dp；
					返回-1；
				解锁ip；
				
				锁住dp；
				调用函数，将dp中off处的目录项清空；
				如果ip指向的是目录
					将dp->link_num减去1；
					写回dp；
				解锁并丢弃dp；
				
				锁住ip；
				将ip->link_num减去1；
				如果ip指向的是目录
					将ip->link_num减去1；
				写回ip；
				解锁并丢弃ip；
				返回0；
					
				注意：
				允许调用这个函数删除目录文件；
				这个函数能够删除设备文件，但是其含义目前尚未定义；
				如果这个path是最后一条指向该文件的路径，且没有任何进程在使用这个文件，那么这个文件将从设备上删除；
				如果这个path是最后一条指向该文件的路径，但是还有进程在使用这个文件，那么这个一直存在直到最后一个引用该文件的open_file_struct被关闭；
				
			创建普通、目录或者设备文件，如果试图创建普通文件且其已经存在则直接返回其inode引用，未上锁：
				接受参数：
					文件路径path；
					文件类型type；
					主设备号major、从设备号minor；
				成功返回该文件对应inode的引用，失败返回NULL
				
				如果path中某个应该是目录的部分不存在或者不是目录，操作失败，返回NULL；
				如果path指定“/”目录，操作失败，返回NULL；
				如果path指定的是./..这两个目录项，操作失败，返回NULL；
				如果是创建普通文件，目标父目录下已存在该文件名，且确实是普通文件，则直接返回对应inode的引用；
				如果是创建普通文件，目标父目录下已存在该文件名，但不是普通文件，操作失败，返回NULL；
				如果是创建目录、设备文件，目标父目录下已存在该文件名，操作失败，返回NULL；
				
				
				调用函数，解析path指定对象的父目录对应inode到dp中，将最后一个元素名字保存在name中；
				如果解析失败
					返回NULL；
				如果name为.或者..
					丢弃dp；
					返回NULL；
				锁住dp；
				调用函数，检查dp下是否有名为name的目录项，结果保存在ip中，不需要偏移量
				如果已经存在
					解锁并丢弃dp；
					锁住ip；
					如果指定创建普通文件，且ip->type也为普通文件
						解锁ip；
						返回ip；
					解锁并丢弃ip；
					返回NULL；
				
				调用函数，分配一个i结点，结果保存在ip中，失败则PANIC；
				锁住ip；
				设置ip->type为设定type；
				将major/minor置为指定值；
				将ip->link_num置为1；
				将ip->size以及ip->addrs中各元素置为0；
				
				调用函数，在dp中添加目录项，名字为name，i结点号为ip->inum；
				如果ip->type为目录
					调用函数，在ip中添加"."和".."，失败则PANIC；
					将dp->link_num增加1；
					将ip->link_num增加1；
					写回dp；
				写回ip；
				解锁并丢弃dp；
				解锁ip；
				
				返回ip；
				
			使指定文件与一个新的打开文件结构关联，可能会创建这个文件，返回与这个打开文件结构关联的文件描述符：
				接受参数：
					指定路径path；
					指定flags；
						必须包含RD_ONLY/WR_ONLY/RD_WR（access mode）之一；
						可选CREAT标志（creation flag）；
						可以将上述值按位或在一起；
				成功返回文件描述符，失败返回-1；
				
				如果指定CREAT
					调用函数，找到这个普通文件的inode引用，如果这个普通文件不存在，则新建这个文件并返回其inode引用，结果保存在ip中；
					如果上述操作失败
						返回-1；
				否则
					调用函数，解析path，结果保存在ip中；
					如果解析失败
						返回-1；
					锁住ip；
					如果ip->type为目录
						如果不是RD_ONLY
							解锁并丢弃ip；
							返回-1；
					解锁ip；
				
				调用函数，分配一个打开文件结构，结果保存在fp中；
				如果分配失败
					丢弃ip；
					返回-1；
				调用函数，分配一个与fp关联的文件描述符，结果保存在fd中；
				如果分配失败
					丢弃fp；
					丢弃ip；
					返回-1；
				
				设置fp->type为inode类型；
				设置fp->mode为设定的模式；
				设置fp->off为0；
				设置fp->ip为上述获得的ip；
				设置fp->pipe为NULL；
				
				返回fd；
				
				注意：
				该函数能够打开/创建普通文件（只读、只写、读写）、只读打开目录文件、打开设备文件（只读、只写、读写）；
			
			文件的组织结构：
				link.c: 提供创建/删除链接的函数实现；
				open.c: 提供创建/打开文件的函数实现；
				fcntl.h: 提供open函数需要的一些flags定义；
				其他所需要的头文件；
		文件系统接口：
			获取并检查用户模式传递给内核的文件描述符：
				n：第n个4字节参数；
				pfd：保存文件描述符的变量；
				pfile：保存打开文件结构指针的变量；
				成功返回0，失败返回-1且不改变*pfd/*pfile的值；
				
				调用函数，获取第n个四字节整数，结果保存在fd中；
				如果上述函数返回-1
					返回-1；
				如果fd<0或者fd>=PROC_OPEN_FD_NUM或者fd在当前进程的打开文件指针列表中对应的指针为NULL
					返回-1；
				如果pfd不为NULL
					将fd保存在*pfd中；
				如果pfile不为NULL
					将fd在当前进程的打开文件指针列表中对应的指针保存在*pfile中；
				返回0；
				
			复制一个文件描述符【系统调用】：
				用户模式参数：
					fd: 待复制的文件描述符；
				用户模式返回值：
					成功返回一个最小、未被使用的文件描述符副本，失败返回-1；
				
				调用函数，读取第0个四字节参数作为fd并进行检查，保存其对应的打开文件结构指针到fp中；
				如果上述函数返回-1
					返回-1；
				调用函数，增加fp引用计数；
				调用函数，分配一个最小、未被使用的文件描述符，使之与fp关联，结果保存在new_fd中；
				如果上述函数返回-1
					返回-1；
				返回new_fd；
				
			从指定文件当前偏移量处读取n个字节到buf中【系统调用】：
				从当前文件偏移量处读取n个字节数据到buf中，文件偏移量将按照实际读取的字节数偏移，实际读取的字节数可能少于n；如果该文件为设备文件或者管道，则其行为取决于设备或管道。
				用户模式参数：
					fd: 待读取的文件；
					buf: 目标缓冲区起始地址；
					n: 要求读取的字节数；
				用户模式返回值：
					成功返回实际读取的字节数，失败返回-1且偏移量不被改变；
				调用函数，读取第0个四字节参数作为fd并进行检查，保存其对应的打开文件结构指针到fp中，如果失败返回-1；
				调用函数，读取第2个四字节参数作为n并进行检查，如果失败返回-1；
				调用函数，读取第1个四字节参数作为buf指针并进行检查，如果失败返回-1；
				调用函数，在fp指定的文件当前偏移量处读取n个字节到buf中，返回值保存在ret中；
				返回ret；
				
			向指定文件当前偏移量处写入从buf开始的n个字节【系统调用】：
				向指定文件当前偏移量处写入从buf开始的n个字节，文件偏移量将偏移n个字节；如果该文件为设备文件或者管道，则其行为取决于设备或管道。
				用户模式参数：
					fd: 待写入的文件；
					buf: 源缓冲区起始地址；
					n: 要求写入的字节数；
				用户模式返回值：
					成功返回n，失败返回-1且偏移量不被改变；
				调用函数，读取第0个四字节参数作为fd并进行检查，保存其对应的打开文件结构指针到fp中，如果失败返回-1；
				调用函数，读取第2个四字节参数作为n并进行检查，如果失败返回-1；
				调用函数，读取第1个四字节参数作为buf指针并进行检查，如果失败返回-1；
				调用函数，在fp指定的文件当前偏移量处写入从buf开始的n个字节，返回值保存在ret中；
				返回ret；
				
			打开或创建路径所指定的文件并返回最小可用文件描述符【系统调用】：
				使指定文件与一个新的打开文件结构关联，可能会创建这个文件，返回与这个打开文件结构关联的文件描述符；不能用于创建设备文件、目录文件、管道；
				用户模式参数：
					path: 指定文件的路径；
					flags: 标志位，参考文件系统接口支持函数部分；
				用户模式返回值：
					成功返回最小可用文件描述符，失败返回-1；
				
				调用函数，获取第0个四字节参数作为字符串指针并进行检查，结果保存在path中，如果失败返回-1；
				调用函数，获取第1个四字节参数作为标志并进行检查，结果保存在flags中，如果失败返回-1；
				调用函数，执行具体的操作，并返回该函数的返回值；
				
			关闭文件描述符【系统调用】：
				关闭所指定的文件描述符使其可重新使用；如果该文件描述符是最后一个对对应打开文件结构的引用则该打开文件结构将被释放掉；如果该打开文件结构是最后一个对对应inode文件的引用且该inode文件已经被移除了所有路径链接则该文件将被删除；如果该打开文件结构是最后一个被关闭的管道端口则管道将被释放。
				用户模式参数：
					fd: 待关闭的文件描述符；
				用户模式返回值：
					成功返回0，失败返回-1；
				
				调用函数，读取第0个四字节参数作为fd并进行检查，保存其对应的打开文件结构指针到fp中，失败返回-1；
				调用函数，执行具体操作；
				返回0；
				
			获取文件描述符对应inode的信息【系统调用】：
				如果文件描述符对应设备文件，则其含义取决于设备；如果对应管道，则返回-1；
				用户模式参数：
					fd: 目标文件描述符；
					st: stat结构指针；
				用户模式返回值：
					成功返回0，失败返回-1；
				
				调用函数，读取第0个四字节参数作为fd并进行检查，保存其对应的打开文件结构指针到fp中，如果失败返回-1；
				调用函数，获取第1个四字节参数作为stat结构指针并进行检查，结果保存在st中，如果失败返回-1；
				调用函数，执行具体操作；
				返回上述函数的返回值；
			
			为一个文件创建一个新路径【系统调用】：
				为一个已存在的文件创建一条新的路径，如果新路径已经存在则不会被覆盖；具体参考文件系统接口支持函数；
				用户模式参数：
					oldpath: 指定文件；
					newpath: 一条新的指向指定文件的路径；
				用户模式返回值：
					成功返回0，失败返回-1：
				调用函数，获取第0个四字节参数作为字符串参数指针并进行检查，结果保存在oldpath中，如果失败返回-1；
				调用函数，获取第1个四字节参数作为字符串参数指针并进行检查，结果保存在newpath中，如果失败返回-1；
				调用汉，执行具体操作，并返回该函数的返回值；
				
			删除一条路径，可能会删除该路径指定的文件【系统调用】：
				从文件系统中删除一条路径。如果这条路径是最后一条引用该文件的路径且没有进程打开该文件则该文件将被删除，所占据空间将被释放掉。如果这条路径是最后一条引用该文件的路径但是仍有进程打开该文件则该文件将被保留直到最后一个对该文件对应inode的引用被丢弃。
				用户模式参数：
					path: 指定删除的路径；
				用户模式返回值：
					成功返回0，失败返回-1；
				调用函数，获取第0个四字节参数作为字符串参数指针并进行检查，结果保存在path中，如果失败返回-1；
				调用函数，执行具体操作，并返回该函数的返回值；
				
			创建一个目录文件【系统调用】：
				用户模式参数：
					path: 该目录的路径；
				用户模式返回值：
					成功返回0，失败返回-1；
				调用函数，获取第0个四字节参数作为字符串参数指针并进行检查，结果保存在path中，如果失败返回-1；
				调用函数，创建一个以path为路径的目录文件，主从设备号均设为0，返回结果保存在ip中；
				如果ip等于NULL
					返回-1；
				返回0；
			
			创建一个设备文件【系统调用】：
				在文件系统中创建一个结点，当结点类型为设备时，通过major/minor指定其设备号，否则major/minor将被忽略。
				用户模式参数：
					path: 该结点的路径；
					type: 结点类型，目前可用类型为字符设备；
					major: 主设备号；
					minor: 从设备号；
				用户模式返回值：
					成功返回0，失败返回-1；
				调用函数，获取第0个四字节参数作为字符串参数指针并进行检查，结果保存在path中，如果失败返回-1；
				调用函数，获取第1个四字节参数作为结点类型并进行检查，结果保存在type中，如果失败返回-1；
				调用函数，获取第2个四字节参数作为主设备号并进行检查，结果保存在major中，如果失败返回-1；
				调用函数，获取第3个四字节参数作为从设备号并进行检查，结果保存在minor中，如果失败返回-1；
				如果不是字符设备类型
					PANIC；
				调用函数，创建一个以path为路径的设备文件，主从设备好为major和minor，返回结果保存在ip中；
				如果ip等于NULL
					返回-1；
				返回0；
			
			改变进程当前工作目录【系统调用】：
				用户模式参数：
					path: 新的工作目录；
				用户模式返回值：
					成功返回0，失败返回-1；
				调用函数，获取第0个四字节参数作为字符串参数指针并进行检查，结果保存在path中，如果失败返回-1；
				调用函数，解析path，返回结果保存在ip中；
				如果ip为NULL
					返回-1；
				锁住并读取ip；
				如果ip指向不是目录
					解锁并丢弃ip这个引用；
					返回-1；
				解锁ip；
				丢弃对当前工作目录对应inode的引用；
				设置当前进程的工作目录为ip；
				返回0；
				
			创建管道【系统调用】：
				用户模式参数：
					p[2]: 由两个文件描述符组成的数组的地址；
				用户模式返回值：
					成功返回0，p[0]中保存只读文件描述符，p[1]中保存只写文件描述符，可用于向管道读写，失败返回-1且p[]数组中数据不会被修改；
					
				调用函数，获取第0个四字节参数做为数组指针并进行检查，结果保存在p中，如果失败返回-1；
				调用函数，创建管道，并获得与之关联的两个打开文件结构引用，结果保存在fp0/fp1中，如果失败返回-1；
				调用函数，从当前进程的打开文件指针表中分配一个文件描述符与fp0关联，结果保存在fd0中，如果失败跳转到bad处；
				调用函数，从当前进程的打开文件指针表中分配一个文件描述符与fp1关联，结果保存在fd1中，如果失败跳转到bad处；
				将fd0写入p[0]；
				将fd1写入p[1]；
				返回0；
				
				bad:
				如果fd0大于等于0
					将当前进程中fd0对应的打开文件结构指针置为NULL；
				调用函数，关闭fp0和fp1，使管道也被释放；
				返回-1；
			文件的组织结构：
				sys_file.c: 上述函数的实现；
				
	6.I/O管理
		《1》文本模式下的显卡驱动
		
			描述：
			该驱动主要实现对屏幕的文本输出。可以写入的对象包括单个字符和字符串；两者都有文本内容、颜色以及是
			否闪烁几种属性可以指定，但不包括位置属性--所有对象默认从光标位置处开始写入。整个屏幕被视为80*25
			的矩形，
			设置以左上角字符位置为二维坐标系原点（0,0），横轴方向指向左边，纵轴方向指向下方，每一个坐标位置
			都指定一个字符位置。
			对于LF(ASCII码)字符的处理：
				如果光标下移一行的位置超出屏幕最底行则先对屏幕内容进行滚动，
				处理之后再将光标设置为下一行的行首位置；
			对于CR(ASCII码)字符的处理：
				光标移动到当前行的行首位置；
			对于HT(ASCII码，水平制表字符)字符的处理
				每一个HT字符都使得光标移动到当前行中下一个模4为0的位置上；如果光标位置超出了屏幕的最右边，
				则将光标位置置为下一行的行首位置，如有必要（光标处于屏幕最底行）则对屏幕内容
				进行滚动；
			对于BS(ASCII码，Backspace字符)字符的处理：
				光标在当前行中回移一个位置，如果光标位置超出了屏幕最右边则保持其原有位置不动
			对于ASCII码表中其他控制字符的处理：
				//以Caret记法
				和ASCII码表中可打印字符做相同处理；
			对于ASCII码表中可打印字符的处理：
				在当前光标位置处写入该字符，光标移动到下一个待写入的位置，如果光标位置超出了屏幕的最右边，
				则将光标位置置为下一行的行首位置，如果此位置超出屏幕所能表示的最后一个字符位置则对屏幕内容
				进行滚动；
			如果对屏幕内容进行了滚动，则消失的行不予保存，新增的行将被空白字符填充，方便写入新内容。
			滚动时，光标位置随之向上移动一行，如果这导致光标位置超出屏幕的最上方，则光标在原位置不动。
			
			
			需要向外提供的功能：
				清空屏幕
					进行清屏操作，方便后续写入字符；使用空白字符+（前景白色、背景黑色）填充每一个显存字节，
					且使光标移动到屏幕第一个字符位置处
				写入单个字符（分为默认颜色和可设定颜色两个功能）
					默认颜色为前景白色、背景黑色
					对于ASCII码表中不同字符的处理则依照上述约定
				移动光标到指定位置
					将光标移动到二维坐标系（详见上述约定）中任意指定位置
				获取当前光标位置
					返回当前光标在二维坐标系（详见上述约定）中的位置
				写入一个以NUL（ASCII码，空字符）字符结尾的字符串
					对于字符串中的每一个字符，依次按照上述约定处理
			封装一个向屏幕格式化输出字符串的函数：
				调用一个格式化输出字符串到缓冲区的函数
				再将该缓存区中的字符串输出到屏幕上
		
		《2》8253/8254 PIT
			针对8253/8254 PIT，选择channel 0，lobyte/hibyte 的access mode，Square Wave Mode，binary format，
			所以发送给PIT的命令字是 0011 0110(0x36)
			提供的功能：
				初始化PIT
					先初始化PIT，能够指定大致的工作频率（1s产生多少次中断），其余设置固定
					然后允许PIC接收该中断
		《3》IDE硬盘
			目前仅支持一个硬盘，假设其作为在IDE primary bus上的master设备，设定大小为64MB，采用LBA28模式寻址，其设备号为0。假定该硬盘一次只能处理一个请求。
			在内核中有一个数据结构（buf）对应于硬盘上的一个扇区，也可以代表一个磁盘请求，驱动程序对buf结构进行操作，详见块缓冲。
			对于驱动程序而言，buf应当是BUSY的，表明只有一个进程在占用该buf；当VALID没有被设置时，表明buf内没有有效的sector数据，此时将从硬盘读出sector到buf中，当DIRTY被设置时，表明buf内数据与对应sector数据不同步，此时将buf内数据写入对应sector中。
			在驱动中，将维护一个磁盘请求队列，所有的磁盘请求都将按先后顺序加入这个队列中；驱动程序将队列中第一个请求交给硬件处理，然后睡眠下去，交出CPU，完成后硬件将发起一个IRQ，对应中断处理程序将接收这个工作，并唤醒在这个buf上睡眠的所有进程，如果队列中还有请求，则继续将队列头部的请求交给硬件。
			
			需要的功能：
				IDE硬盘初始化：
					在PIC的IMR中允许对应的中断通过
					注册处理ide中断的函数
					轮询驱动的状态寄存器，直到其准备好，不检查错误
				同步buf和磁盘：
					如果buf是UN-BUSY的，没有进程占有该buf，PANIC
					如果buf是VALID并且UN-DIRTY，说明buf和sector已经同步，调用者可能有问题，PANIC
					
					关中断，确保只有一个进程能修改磁盘请求队列
					
					将buf插入磁盘请求队列尾部，并将buf.qnext置空
					如果队列中仅当前一个请求
						调用函数，将请求提交给硬件
					轮询buf是否VALID且UN-DIRTY
						不是则睡眠在buf上，等待被中断处理程序唤醒，唤醒后继续轮询
						是则退出轮询
					
					恢复原来的中断状态
					
					返回调用者
				将请求提交给硬件：
					轮询驱动的状态寄存器，直到其准备好，不检查错误
					允许硬件完成操作时发起IRQ
					给出需要操作的sector数量
					依次写入LBA28的低24位到三个寄存器中
					使用LBA28，选择master驱动，并给出LBA28的高4位
					如果buf是DIRTY的
						发起写命令
						将buf中的数据依次写入数据寄存器
					否则
						发起读命令
				中断处理：
					向PIC发送EOI命令
					磁盘请求队列的头一个请求已经完成，删除它（此时无需关中断，因为进入该中断时IF会被CPU清除）
					如果buf是UN-DIRTY，说明之前发起的是读请求
						轮询驱动的状态寄存器，查看其是否准备好，且本次读没有错误发生
							是则从驱动中依次读出数据到buf中
							否则PANIC
					在buf.flags中添加VALID标志
					去除buf.flags中DIRTY标志
					唤醒在该buf上睡眠的进程
					查看请求队列中是否还有请求
						是则调用函数，将该请求提交给硬件
				轮询等待驱动RDY（指定检查错误寄存器标志）
					轮询驱动的状态寄存器，查看其是否UN-BSY且RDY
					从轮询中退出后，如果需要检查错误
						读取驱动的错误寄存器，存在错误则返回0
					返回1
			文件的组织结构：
				ide.h：相关数据结构的定义，提供相关接口
				ide.c：提供驱动程序的实现
				
		
		《4》块缓冲
				在内核中实现一个块缓冲层，这个数据结构用于加快块设备（硬盘、软盘）的访问速度，并提供一个同步点，一个buf同时只能被一个进程使用；一个块设备上的sector只能对应一个buf。
				块缓冲拥有固定数量的buf（目前暂设为20个），当找不到sector对应的buf时，将使用一个空闲的buf（UN-BUSY），此时将从块设备中读取数据以保持一致；搜索时采用LRU策略。
				块缓冲为一个固定长度的buf数组，但是在初始化后将被链接成一个双向链表，之后只能通过双向链表访问，以维持LRU的性质。链表的一端为最近最少被使用的buf（LRU），另一端则为最近刚被使用过的buf（MRU）。
				在使用buf时，进程必须先通过获取buf的函数来获得一个buf，该函数返回的buf数据是和指定设备上的sector保持一致的，至此之后该buf以及该buf对应的sector都将被该进程占有，其他想获得该sector的进程将会睡眠直到该进程释放这个buf；当该进程对buf进行修改后，必须及时调用更新buf的函数，来同步buf与对应设备上sector之间的内容；当进程不再需要该buf时，必须及时释放该buf使得其能被其他进程使用。
				目前的设计中，在以下情况下会出现死锁：
					进程A持有buf1，想要继续持有buf2
					进程B持有buf2，想要继续持有buf1
				解决上述问题的一种方法是一个进程在获取一个buf前，必须先释放之前持有的buf；或者设计一种接口，使得一个进程能一次性获得多个buf。
				buf结构如下：
					dev			设备号，为负数时表示非可用设备，其余表示可用设备
					sector		扇区号
					flags
						BUSY	这个buf结构正被某个进程占用
						VALID	这个buf中的数据可以使用（不一定和对应的sector相同）
						DIRTY	这个buf中的数据被修改了
					data		对应sector中的数据
					qnext		指向下一个磁盘请求
					next		next和prev实现块缓冲中的双向链表
					prev
				对flags的解释：
					BUSY	VALID	DIRTY
					1		0		0		被进程占有，但buf中没有有效数据，需要从块设备中读取
					1		1		0		被进程占有，buf中数据已经和块设备一致，可以使用
					1		1		1		被进程占有，buf中数据被修改过了
					0		0		0		没有进程占用且无有效数据，即空闲的buf
					0		1		0		没有进程占用且已经包含有有效数据，buf处于空闲中
					其余情况不允许出现
					
				块缓冲结构如下：
					buf[BUF_COUNT]	块缓冲中的buf
					head					buf结构，通过next指针可以按照MRU（最近刚被使用的）顺序遍历块缓冲；通过prev指针可以按照LRU（最近最少被使用的）顺序遍历块缓冲；不管是哪种顺序，最终都能返回到head处；其余域均不使用。
				需要提供的接口：
					假设块缓冲结构体变量为buf_cache
					初始化块缓冲：
						从buf_cache.buf[BUF_COUNT-1]到buf_cache.buf[1]
							buf_cache.buf[i].next = &buf_cache.buf[i-1]
							buf_cache.buf[i-1].prev = &buf_cache.buf[i]
							buf_cache.buf[i].dev = -1
							
						buf_cache.buf[BUF_COUNT-1].prev = &buf_cache.head
						buf_cache.buf[0].next = &buf_cache.head
						buf_cache.buf[0].dev = -1
						
						buf_cache.head.prev = &buf_cache.buf[0]
						buf_cache.head.next = &buf_cache.buf[BUF_COUNT-1]
						
					将指定buf移动到MRU端：
						if buf == buf_cache.head.next
							此时buf已经处于MRU端，无需移动，直接返回
						buf->next->prev = buf->prev
						buf->prev->next = buf->next
						
						buf_cache.head.next->prev = buf
						buf->next = buf_cache.head.next
						
						buf->prev = &buf_cache.head
						buf_cache.head.next = buf
						
					获取一个映射到指定dev/sector上的buf，该buf将移动到MRU的位置且设置为BUSY的（dst_dev，dst_sector）：
						关闭中断
						
						从buf_cache.head.next开始遍历块缓冲，查看dst_dev/dst_sector是否已经在块缓冲中
							如果buf.dev==dst_dev && buf.sector==dst_sector
								查看该buf是否BUSY
								不是
									在buf.flags中添加BUSY标志
									调用函数，将该buf移动到MRU端
									
									恢复原来的中断状态
									
									返回该buf
								睡眠在该buf上，等待被唤醒
								唤醒后重新从buf_cache.head.next开始遍历块缓冲
						dst_dev/dst_sector不在缓冲中，从buf_cache.head.prev开始遍历块缓冲
							如果找到一个buf.flags为UN-BUSY的，即为一个空闲的buf
								设置buf.dev为dst_dev
								设置buf.sector为dst_sector
								设置buf.flags为BUSY
								调用函数，将该buf移动到MRU端
								
								恢复原来的中断状态
								
								返回该buf
						
						没有找到空闲的buf，PANIC
						
					请求一个映射到指定dev/sector上的buf（dst_dev，dst_sector）：
						调用函数，先获取一个映射到指定dev/sector上的buf
						判断该buf中是否有可用数据，即是否为VALID
						不是
							调用设备驱动函数，同步buf和sector，同步中会可能会睡眠
						返回buf指针，此时buf是BUSY、VALID、UN-DIRTY的

					同步buf和对应sector：
						如果buf.flags为UN-BUSY的，则PANIC
						在buf.flags中添加DIRTY标志
						调用设备驱动函数，同步buf和sector，同步中会可能会睡眠
					释放buf：
						如果buf.flags是UN-BUSY的，PANIC
						在buf.flags中去除BUSY标志
						唤醒在该buf上等待的进程
						
				
				文件的组织结构：
					buf_cache.h：提供buf结构定义以及向外提供的接口声明
					buf_cache.c：提供相关的接口实现
					
		《5》PS/2键盘：
			目前支持常用的mf PS/2键盘（在bochs中配置，经过测试，在未经配置的情况下，PS/2控制器使用scan code set 1）。每当按下或者释放键时，PS/2控制器将会发起中断，8259A PIC将接受该中断并转发给CPU，随后将控制交给键盘驱动程序，键盘驱动程序将从控制器相应端口读取数据，并提交给上层函数；驱动程序只是转发scan code，由高层负责解释。
			
			
			提供的接口：
				键盘中断处理：
					从控制器控制端口读取状态字节；
					如果状态字节表明output buffer是空的
						返回；
					从控制器数据端口读取数据字节；
					调用TTY控制函数，传递该数据字节；
				初始化键盘设备处理：
					注册键盘中断处理函数；
					修改IMR，使得键盘中断能够通过8259A转发给CPU；
			
			文件的组织结构：
				keyboard.c: 键盘中断处理、初始化函数的实现；
				keyboard.h: 上述函数的相关声明；
				keymap.c: 提供扫描码、按键值等定义；
		《6》TTY虚拟设备：
			构想：
				将TTY定义为可供进程进行输入和输出操作的虚拟设备，输入是通过键盘提供数据，输出则是写入显存，通过屏幕显示。目前仅支持一个TTY设备，定义其主从设备号均为0。默认采取回显的机制，即每从键盘输入一个可见字符，则在屏幕上直接显示出来。TTY设备拥有一个输入缓冲区，按键产生的数据通过键盘驱动程序传递给TTY设备后，将被进一步转换处理，然后写入输入缓冲区。
				定义TTY输入缓冲区如下：
					buf			环形缓冲区，用于保存转换后的按键值，定义128字节长度
					r			缓冲区索引，从r到w范围内为进程可读的按键值，这些按键值不可被编辑
					w			缓冲区索引，从w到e范围内为可编辑的按键值
					e			缓冲区索引，指向下一个按键值写入的位置
				
				进程通过TTY设备的读函数从TTY的输入缓冲区中获取数据，当缓冲区中没有数据时该进程则会睡眠下去直到被唤醒；如果有多个进程读取数据，可能会进行交错的读取。目前对TTY输入缓冲区设置的是行缓冲机制，即当满一行（按下enter键）、缓冲区已满时唤醒等待在缓冲区上的所有进程；一次读取最多读取一行内容；当缓冲区已满时停止写入输入缓冲区，继续输入的数据将被忽略；在进程未读取数据之前，可以编辑一行所输入的内容，编辑效果在屏幕上直接可见。
				当进程调用TTY设备的写函数，则是直接写入显存，在屏幕上显示，使用默认属性；同时只能有一个进程能够写入TTY设备。
				
			提供的接口：
				将扫描码转换为对应按键和动作的组合：
					sc，扫描码；
					如果当前sc或者和之前输入的sc结合起来，能够表达出一次按键动作的含义，那么将返回一个表示该按键动作含义的值，否则返回0；
					
					如果sc是0xE0
						在flags中添加e0esc标志；
						返回0；
					否则
						如果sc是break code
							如果sc表示左shift/右shift键被释放，则清除flags中对应shift标志；
							返回0；
						否则
							当前sc是make code；
							如果flags中已经有shift标志
								查询shift_map中sc对应的值，保存在data中；
								如果flags中已经有capslock标志且data表示26个大写英文字母
									将对应英文字母转换为小写，保存在data中；
								返回data；
							否则
								如果flags中已经有e0esc标志
									查找e0_map中sc对应的值，保存在data中；
									清除flags中的e0esc；
									返回data；
								否则
									查找normal_map中sc对应的值，保存在data中；
									如果data表示左/右shift被按下
										在flags中添加对应shift标志；
										返回0；
									否则如果data表示capslock被按下
										如果flags中已经有capslock标志则关闭该标志，否则开启该标志；
										返回0；
									否则
										如果flags中已经有capslock标志且data表示26个小写英文字母
											将对应英文字母转换为大写，保存在data中；
										返回data；
					注意：
					该函数仅仅处理了数字、字母、部分shift组合键、capslock键等常用键；与alt/ctrl有关的键以及一些其他键均未提供支持
				
				对键盘输入数据做出响应：
					sc，扫描码；
					
					处理从键盘输入的数据，包括写入缓冲区使之对进程可读，回显在屏幕上(使用默认属性)；
					
					调用函数，将sc转换为表示当前按键状态的值，保存在data中；
					如果data == 0
						忽略这次按键，返回；
					如果data表示backspace键被按下
						如果e != w
							令e--；
							调用函数，输出backspace字符，这导致光标回退一个字符位置；
							调用函数，输出空格字符，这导致上一个写入的字符被覆盖掉；
							调用函数，输出backspace字符，再使光标回退一个字符位置；
						否则忽略该按键；
					否则
						如果(r <= e 且 e - r < sizeof(buf))或者(r > e且e%sizeof(buf) < r%sizeof(buf))
							如果data表示enter键被按下
								令data为'\n'字符；
							如果data表示tab键被按下
								令data为'\t'字符；
							将data写入输入缓冲区中e%sizeof(buf)所指定的位置；
							令e++；
							调用函数，输出data；
							如果data为'\n'或者e == r+sizeof(buf)
								令w为e所在位置；
								唤醒等待在TTY设备上的所有进程；
								
					注意：
					该函数要求输入缓冲区长度应该是2的次幂
				从TTY设备读取数据：
					dst: 目标缓冲区；
					n: 所需要读取的字节数；
					从TTY设备的输入缓冲区读取一行（在'\n'处结束，包括'\n'）或者n个字节的数据（以先满足的条件为准）写入dst处，没有数据可读时会睡眠下去直到被唤醒，成功返回实际读取的字节数，没有失败情况；
					
					将n的值保存在old_n中；
					关闭中断；
					当n>0时，循环执行下述语句
						当r等于w时，循环执行下述语句
							说明没有数据可读；
							睡眠在TTY设备上；
						将输入缓冲区中r%sizeof(buf)处所指定的数据写入dst处；
						令r++，n--，dst++；
						如果之前所写入数据是'\n'字符
							退出循环；
					恢复原先的中断状态；
					返回old_n-n；
				
				向TTY设备写入数据：
					src: 源缓冲区；
					n: 所需要写入的字节数；
					向屏幕当前光标处写入从src开始的n个字节的数据，使用默认属性（无闪烁、白色前景、黑色背景），成功返回n，没有失败情况；
					
					关闭中断；
					当n>0时，循环执行下述语句
						调用函数，向当前光标处写入src所指定的字节，使用默认属性；
						令n--，src++；
					恢复原先的中断状态；
				初始化TTY设备：
					初始化字符设备表中TTY设备对应的表项；
			文件的组织结构：
				tty.c: TTY设备操作函数的实现；
				tty.h: TTY设备相关定义、接口的声明；
	7.用户shell
		构想：
			
		文件的组织结构：
			sh.c: shell的实现；
	8.用户程序库：
		格式化输出到bochs控制台【过渡使用】：
			fmt: 格式化字符串；
			变参：待格式化的参数；
			成功返回输出的字符个数（不包括结尾的NUL字符），失败返回-1；
			
			调用库函数，格式化需要输出的内容，结果保存在buf中；
			如果解析失败
				向bochs控制台输出错误信息；
				返回-1；
			否则
				发起系统调用，将buf中的内容输出到bochs控制台；
				返回buf中内容的长度；
		格式化输出到屏幕：
			fmt: 格式化字符串；
			变参：待格式化的参数；
			成功返回输出的字符个数（不包括结尾的NUL字符），失败返回-1；
			
			调用库函数，格式化需要输出的内容，结果保存在buf中；
			如果解析失败
				发起系统调用，向标准错误输出端输出错误信息；
				返回-1；
			否则
				发起系统调用，将buf中的内容输出到标准输出端；
				返回buf中内容的长度；
		从指定文件中读取一行数据到缓冲区中：
			fd: 已打开的文件描述符，允许读取；
			buf: 缓冲区起始地址；
			n: 最多读取的字符数为n-1；
			从fd指定文件中读取最多n-1个字符，在遇到'\n'字符或者文件结尾时结束读取；如果读到了'\n'字符则也将保存该字符到buf中；读取结束后在最后一个被读取字符的后面添加一个NUL字符。成功返回实际读取字符个数，失败返回-1；
			
			保存n到old_n中；
			当n>1时，循环执行下述语句
				从fd中read出一个字符，保存在c中；
				如果上述函数返回-1；
					返回-1；
				否则如果返回0；
					退出循环；
				将c保存在buf中；
				令n--,buf++；
				如果c为'\n'字符
					退出循环；
			在buf指向位置处写入NUL字符；
			返回old_n - n的值；	
			
		从指定文件中读取一个字符：
			fd: 已打开的文件描述符，允许读取；
			从fd指定文件中读取一个字符，转换为int32_t类型并返回；失败或者遇到文件结尾则返回-1；
			
			从fd中read出一个字符，保存在c中；
			如果上述函数返回值小于等于0
				返回-1；
			返回c；
		文件的组织结构：
			usr/lib/ulib.c: 用户程序可以使用的一些库函数；
			usr/lib/ulib.h: 上述库函数的声明；
	9.被内核使用的一些库函数
		格式化输出到缓存区的函数
			对控制格式化输出的format string进行解析
			对于普通字符，直接写入缓存区中
			对于conversion specification(即 %[length_modifier]conversion_specifier)，则分情况处理（参照下面对length_modifier和conversion_specifier的说明）
			循环处理format string的字符，直到遇到一个'\0'字符，该字符也会被写入缓存区
			函数将返回所写入的总字符数（不包括结尾的'\0'字符），解析失败返回-1；
			
			conversion_specifier:
				c: 按照无符号ASCII字符解释
				s: 按照ASCII字符串解释，字符串必须以'\0'字符结尾，'\0'字符不会被写入缓存区
				d: 按照有符号十进制整数解释
				o: 按照无符号八进制整数解释，使用前缀0
				u: 按照无符号十进制整数解释
				x: 按照无符号十六进制整数解释，使用前缀0x以及abcdef
				X: 按照无符号十六进制整数解释，使用前缀0X以及ABCDEF
				b: 按照无符号二进制整数解释
				p: 按照void *类型指针值解释，即相当于X
				%: 转义'%'字符，即使用"%%"可以输出一个"%"
			若%后不存在合法的conversion_specifier，则报错，返回-1
			
			length_modifier:
				hh: 表示长度为一个char类型大小（一个字节）
					后面可接d:o:u:x/X:b这些conversion specifier，对于其他conversion specifier则报错，返回-1
				h: 表示长度为一个short类型大小（两个字节）
					后面可接d:o:u:x/X:b这些conversion specifier，对于其他conversion specifier则报错，返回-1
				l: 表示长度为一个long类型大小（四个字节）
					后面可接d:o:u:x/X:b这些conversion specifier，对于其他conversion specifier则报错，返回-1
				z: 表示长度为一个size_t类型大小（四个字节）
					后面可接d:o:u:x/X:b这些conversion specifier，对于其他conversion specifier则报错，返回-1
				若没有length_modifier，则表示长度为一个int类型大小（四个字节）
	10.GDT相关
		布局：
			第一个条目为全0
			第二个条目为内核模式代码段
				段界限：0xFFFFF	段的界限
				段基址：0x0		段基地址
				粒度（G）：1b	表示段界限以4KB为单位
				D/B位：1b	32位代码
				L位：0b		非64位代码
				AVL位：0b	暂时不使用AVL位
				P位：1b		该段存在于内存中
				DPL：00b	只有特权级0代码才能跳转到该代码段中
				S位：1b		代码段或者数据段
				TYPE：1000b	可执行、不依从、可读、未被访问过
				0xFFFF 0x0000 0x00 1100,1111,1001,1010(0xCF9A) 0x00
			第三个条目为内核模式数据段
				段界限：0xFFFFF	段的界限
				段基址：0x0		段基地址
				粒度（G）：1b	表示段界限以4KB为单位
				D/B位：1b	当ss寄存器指向该数据段时，应当使用ESP
				L位：0b		非64位代码
				AVL位：0b	暂时不使用AVL位
				P位：1b		该段存在于内存中
				DPL：00b	只有特权级0代码才能操作数据段中的数据
				S位：1b		代码段或者数据段
				TYPE：0010b	不可执行、向上拓展、可写、未被访问过（默认可读）
				0xFFFF 0x0000 0x00 1100,1111,1001,0010(0xCF92) 0x00
			第四个条目为用户模式代码段
				段界限：0xFFFFF	段的界限
				段基址：0x0		段基地址
				粒度（G）：1b	表示段界限以4KB为单位
				D/B位：1b	32位代码
				L位：0b		非64位代码
				AVL位：0b	暂时不使用AVL位
				P位：1b		该段存在于内存中
				DPL：11b	特权级3代码就能跳转到该代码段中
				S位：1b		代码段或者数据段
				TYPE：1000b	可执行、不依从、可读、未被访问过
				0xFFFF 0x0000 0x00 1100,1111,1111,1010(0xCFFA) 0x00
			第五个条目为用户模式数据段
				段界限：0xFFFFF	段的界限
				段基址：0x0		段基地址
				粒度（G）：1b	表示段界限以4KB为单位
				D/B位：1b	当ss寄存器指向该数据段时，应当使用ESP
				L位：0b		非64位代码
				AVL位：0b	暂时不使用AVL位
				P位：1b		该段存在于内存中
				DPL：11b	特权级3代码就能操作该数据段中的数据
				S位：1b		代码段或者数据段
				TYPE：0010b	不可执行、向上拓展、可写、未被访问过（默认可读）
				0xFFFF 0x0000 0x00 1100,1111,1111,0010(0xCFF2) 0x00
			第六个条目为TSS描述符
				段界限：TSS结构体大小，104字节
				段基址：TSS结构体变量地址
				粒度（G）：0b	表示段界限以字节为单位
				D/B位：0b	固定值
				L位：0b		固定值
				AVL位：0b	暂时不使用AVL位
				P位：1b		该段存在于内存中
				DPL：00b	特权级0代码才能操作该段中的数据
				S位：0b		系统段
				TYPE：1001b	固定格式，B位为0，表明任务不忙
				0000 0000 1000 1001(0x89)
		需要的功能：
			一个用来建立默认GDT的函数
			设置GDT条目
			刷新GDTR
		面临的问题：
			如果使用汇编过程实现刷新GDTR，那么.flush的偏移地址为多少，这个汇编过程处于内存中的哪个位置
				.flush在链接过程被正确的重定位了；这个汇编过程会在内核文件的.text section中
			如何实现C与汇编过程相互调用
	
	11.DEBUG相关：
		向运行bochs的控制台输出格式化信息的工具函数：
			该函数利用格式化输出到缓存区的函数以及bochs提供的port_e9_hack功能实现；
			两个版本，一个使用pushcli/popcli，另一个不使用，便于在scheduler线程和外部硬件中断处理程序中使用；
		在建立用户模式下格式化输出库之前使用的系统调用：
			该系统调用为0号系统调用；
	
	12.用户程序/进程构建及运行：
		构想：
			第一个进程初始的代码和数据和内核链接在一起；系统随后将利用这段代码和数据创建并运行第一个进程，该进程随即发起系统调用，加载使用C编写的用户程序并以此替换当前进程的内存镜像，这样就能通过C来更加灵活的进行系统剩余的配置。
			在第一个用户进程中，将在根目录下创建一个tty设备结点（如果根文件系统中没有该结点的话），并打开该设备，使得0、1、2这三个文件描述符均对应该设备；按照惯例，将0作为标准输入文件描述符，默认与键盘输入，1和2分别作为标准输出文件描述符和标准错误输出文件描述符，默认输出到屏幕。这个进程随后将创建一个子进程用于执行shell，shell进程即作为系统的用户接口；随后当前进程将循环等待子进程或孙子进程退出；所有进程退出后将进入无限循环状态。
			除刚创建用户进程时，每一个用户程序都会链接公共的进入/退出封装代码、系统调用封装代码、用于实现自身逻辑的功能代码和相关数据。当系统加载一个用户程序为进程后，将从公共的进入代码进入进程的处理逻辑（main函数）中，执行中该进程可以使用系统调用封装代码发起系统调用，以满足其需求，执行完毕后，又将返回到公共的退出代码，以完成系统资源的回收。
			公共的进入/退出封装代码、封装系统调用的代码遵循cdecl，用户程序可以通过标准的函数调用方式发起系统调用。
			
			main函数是用户进程的逻辑主体，其原型为：
				int32_t main(void)或者int32_t main(int32_t argc, char * argv[])
			argc表示参数个数，argv则是一个包含各个字符串参数指针（所指向的字符串均以NUL字符结尾）的列表；目前设定最大参数个数为32个，如果参数个数少于32（MAX_ARG_NUM）个，则最后一个参数的后面将设置一个NULL指针表示结尾位置；argv中各个元素以及所指向的字符串目前是可以修改的，但实际上没有意义。
			在main函数执行之前，需要在用户栈中准备好main函数所需要的参数；目前设定的用户栈布局如下：
					|string 0
					|string 1
					|...
					|string argc-1
					|NULL		<=== 可能存在NULL指针
					|argv[argc-1]
				^	|...
				|	|argv[1]
				|	|argv[0]
			   addr	|argv
					|argc
					|eip		<=== esp
			argv[0],argv[1],...,argv[argc-1]分别指向string 0,1,...,argc-1；系统保证string 0,1,...,argc-1均为4字节对齐的。
			main函数执行之后，其返回值作为该进程的退出值，可被其父进程获得。
			
			用户程序可以使用的依赖项包括：
				stdint.h
				stddef.h
				stdarg.h
				fcntl.h
				stat.h
				string.h
				string.c
				usr/inc/sys.h
				
			
			目前系统仅支持从ELF32可执行文件中构建进程镜像。构建ELF32可执行文件时，使用如下脚本定义：
				入口符号：_ustart
				起始VMA/LMA：PROC_LOAD_ADDR
				文本：
					起始LMA等同于VMA；
					按页（4KB）对齐；
					系统调用封装代码；
					公共的用户程序进入/退出代码；
					用户程序代码；
				只读数据：
					起始LMA等同于VMA；
					按页（4KB）对齐；
					所有模块的只读数据；
				可读写数据：
					起始LMA等同于VMA；
					按页（4KB）对齐；
					所有模块的可读写数据；
				未初始化的数据：
					起始LMA等同于VMA；
					按页（4KB）对齐；
				暂不丢弃其余编译/链接中产生的sections，这些sections放在上述sections的后面；
			ELF文件中每一个类型为可加载（PT_LOAD）的prog header，均将按照其vaddr和memsize加载进入内存，成为内存镜像的一部分；目前不管是何种类型的数据（文本、只读数据等），均设置其分页结构对应属性为用户特权级别、可读可写。
			
		需要提供的功能：
			封装系统调用：
				写入系统调用号到eax；
				发起int中断；
				返回；
			进入/退出用户程序：
				call进入main函数，在栈中压入返回eip；
				无限循环中；
			将指定文件中off开始的size大小的内容读入pgdir中addr处：
				ip: 指定文件，要求已上锁；
				off: 文件偏移处；
				size: 内容大小，字节单位；
				pgdir: 指定分页结构；
				addr: pgdir中的某个地址，要求addr到addr+size范围已经映射了内存；
				成功返回实际读入的字节数，失败返回-1；
				
				buf[512]
				old_off = off
				for(; size > 0; size -= min, off += min, addr += min)
					min = MIN(size, sizeof(buf))
					if (min = read_inode(ip, buf, off, min)) == -1
						return -1
					if min == 0
						break
					if copyout(pgdir, addr, buf, min) == -1
						return -1
				return off - old_off
				
				注意：
				该函数仅适用于写入pgdir的用户地址空间中；
				
			加载指定程序替换当前进程内存镜像：
				path: 指定所加载的程序；
				argv: 新进程所需要的字符串参数列表，如果没有MAX_ARG_NUM个，则应该以NULL指针结尾；
				如果加载并设置成功，原进程的分页结构、用户地址空间、进程名将被替换或释放掉，原进程的其余内容保持不变（包括内核栈），函数将不会返回，直接从所加载程序指定的入口开始执行，且main函数的argv[]中从0到argc-1均可访问；如果操作过程中失败，将返回-1且不会对原进程做任何修改。
				
				令ip和new_pgdir为NULL；
				调用函数，解析path，结果保存在ip中；
				如果ip为NULL
					返回-1；
					
				调用函数，锁住ip；
				调用函数，从ip所指向文件的开头处读取ELF header到eh中，返回结果保存ret中；
				如果ret不等于sizeof(ELF header)
					跳到bad处；
				如果eh.magic不是指定魔数或者
				  该文件不是32位ELF或者
				  不是可执行文件
					跳到bad处；
				
				调用函数，创建一个仅包含初始内核地址空间映射的分页结构，结果保存在new_pgdir中；
				如果new_pgdir为NULL
					跳到bad处；
					
				令size为PROC_LOAD_ADDR，从这里开始加载；
				令off从eh.phoff开始，遍历program header table
					调用函数，读取ip中off处的program header到ph中，返回结果保存在ret中；
					如果ret不等于sizeof(program header)
						跳到bad处；
					如果ph不是PT_LOAD类型的
						不处理该ph，继续遍历；
					如果ph.memsize小于ph.filesize
						文件格式有问题；
						跳到bad处；
					调用函数，在new_pgdir中为从size到ph.vaddr+ph.memsize范围映射内存，返回结果保存在size中，这样不管各个ph.vaddr之间是否存在间隙，都统一分配内存；
					如果size不等于ph.vaddr+ph.memsize
						映射失败；
						跳到bad处；
					调用函数，读取ip中ph.offset处，大小为ph.filesize的segment到new_pgdir中ph.vaddr处，返回结果保存在ret中；
					如果ret不等于ph.filesize
						加载该segment失败；
						跳到bad处；
				解锁并丢弃ip这个引用；
				将ip置为NULL，以防止在bad处再次解锁/释放ip；
				调用函数，在new_pgdir中从PROC_USER_STACK_ADDR到PROC_USER_STACK_ADDR+PROC_USER_STACK_SIZE范围映射内存，返回结果保存在ret中；
				如果ret不等于PROC_USER_STACK_ADDR+PROC_USER_STACK_SIZE
					映射失败；
					跳到bad处；
				
				令esp等于PROC_USER_STACK_ADDR+PROC_USER_STACK_SIZE；
				建立stack[2+MAX_ARG_NUM]这个数组，元素大小为4字节，用于保存argc/argv/argv[]这部分的用户栈内容；
				令argc为0，开始遍历argv这个数组中的字符串
					如果argc大于等于MAX_ARG_NUM或者argv[argc]为NULL
						退出遍历；
					令esp为减去strlen(argv[argc])+1之后的值，然后使esp向下按4字节对齐；
					调用函数，将从argv[argc]开始的strlen(argv[argc])+1个字节复制到new_pgdir中从esp开始的位置（包括了结尾的NUL字符），返回结果保存在ret中；
					如果ret等于-1
						跳到bad处；
					将esp的值写入stack[2+argc]处，作为argv数组的值；
					令argc++，继续遍历字符串；
				将argc写入stack[0]，作为main中的argc参数值；
				如果argc < MAX_ARG_NUM
					将NULL写入stack[2+argc]处；
					令argc++；
				将esp-argc*4写入stack[1]，作为main中的argv参数；
				调用函数，将stack[0]到stack[argc+1]之间的元素复制到new_pgdir中从esp-(2+argc)*4开始的位置，返回结果保存在ret中；
				如果ret等于-1
					跳到bad处；
				
				调用函数，解析出path中最后一个元素的位置；
				如果没有元素被解析出，PANIC；
				将最后一个元素名字作为当前进程的新名字，最长不超过PROC_NAME_LLENGTH；
				
				将当前进程的pgdir保存在old_pgdir中；
				关闭中断；
				将当前进程的size设置为size；
				将当前进程的tf->esp设置为esp；
				将当前进程的tf->eip设置为eh.entry；
				将当前进程的pgdir设置为new_pgdir；
				将new_pgdir对应的物理地址加载到CR3中；
				刷新TLB；
				恢复原先的中断状态；
				调用函数，释放与old_pgdir关联的分页结构和所管理的内存；
				返回0；
				
				bad:
					如果ip不为NULL
						解锁并丢弃ip这个引用；
					如果new_pgdir不为NULL
						调用函数，释放new_pgdir；
					返回-1；
			
			检查用户地址空间传递的参数，并调用函数加载指定程序以替换当前进程的内存镜像【系统调用】：
				成功则从所加载程序入口点开始执行，失败则返回-1；
				
				调用函数，取出第0个4字节参数作为字符串指针写入path；
				如果上述函数返回-1
					返回-1；
				调用函数，取出第1个4字节参数作为整型值写入argv；
				如果上述函数返回-1
					返回-1；
				调用函数，检查path处是否一个有效的字符串；
				如果上述函数返回值小于等于0
					返回-1；
				令i为0，遍历argv数组
					如果i大于等于MAX_ARG_NUM
						退出遍历；
					调用函数，从argv+i*4处取出一个4字节整型值作为一个字符串指针写入str_arg中；
					如果上述函数返回-1
						返回-1；
					如果str_arg为NULL
						已经没有更多的字符串参数了，退出遍历；
					调用函数，检查str_arg处是否为一个有效的字符串；
					如果上述函数返回-1
						返回-1；
					令i++，继续遍历；
				
				调用函数，传入path、argv，加载指定程序以替换当前进程的内存镜像，并返回该函数返回的值；
				
		文件的组织结构：
			elf.h: ELF32文件格式定义；
			sys_exec.c: 对exec的封装；
			exec.c：实现exec函数；
			usr/lib/sys_ent.asm：封装系统调用；
			usr/inc/sys.h: 系统调用的C原型；
			usr/inc/int_vectors.inc: 中断向量号，用于汇编过程；
			usr/inc/syscall_numbers.inc: 系统调用号，用于汇编过程；
			usr/lib/user_ent.asm：公共的进入/退出用户程序的封装过程；
			usr/scripts/ulinker.ld：用户程序的链接脚本；
			uinitcode.asm: 链接在内核中、用于构建第一个进程的代码和数据；
			uinit.c: 继续完成系统初始化工作的C程序；
	13.进程间通信
		《1》管道【未测试】：
			在当前文件系统中，拓展支持了管道这一进程间通信方式。管道是内核中一个固定大小的环形缓冲区。创建一个管道，即可获得与该管道关联的两个打开文件结构，分别用于向管道写入或者读取数据。这两个打开文件结构将通过文件描述符的形式返回给进程使用，将这两个文件描述符复制给子进程，则可用于与子进程进行通信。只有当关闭所有与该管道关联的文件描述符该管道才会被关闭。
			管道定义如下：
				buf		环形缓冲区，用于保存管道数据，定义为1024字节大小
				ridx	读索引，读取从ridx%sizeof(buf)处开始
				widx	写索引，写入从widx%sizeof(buf)处开始
				ropen	非0表示仍然有用于读取的文件描述符与该管道关联，否则表示该管道不再可读
				wopen	非0表示仍然有用于写入的文件描述符与该管道关联，否则表示该管道不再可写
			从ridx到widx之间为可读的数据；由于ridx/widx可表示的值大于sizeof(buf)，所以当ridx等于widx时，表示缓冲区为空，当ridx+sizeof(buf)等于widx时表示缓冲区已满。
			对于表示管道的打开文件结构，其文件偏移和inode结构指针没有定义，对其进行stat也未定义。
			从管道读取数据时，如果管道为空且管道的写入端仍未被关闭，则先唤醒待写入的进程，然后睡眠下去直到有数据被写入，否则则从管道读取数据，并唤醒待写入的进程，然后返回；如果管道中数据不够也不会睡眠，而只是读完所能读取的数据。向管道写入数据时，如果管道已满，而且管道的读端口已经被关闭，则放弃写入操作，否则唤醒等待读取数据的进程然后睡眠下去；
			
			需要的接口：
				创建管道：
					prfile：与管道读取端关联的打开文件结构指针的地址
					pwfile：与管道写入端关联的打开文件结构指针的地址
					成功将创建一个管道，并使两个打开文件结构分别作为管道的读写端，其地址分别写入*prfile/*pwfile中，*prfile用于从管道中读取数据，*pwfile用于向管道写入数据，然后返回0；失败则返回-1
					
					调用函数，分配一个页面用作管道结构，结果保存在pipe中；
					如果pipe为NULL
						返回-1；
					调用函数，将pipe结构清零；
					将pipe->ropen和pipe->wopen均置为1；
					调用函数，分配一个打开文件结构，结果保存在fp0中；
					如果fp0为NULL
						跳到bad处；
					调用函数，分配一个打开文件结构，结果保存在fp1中；
					如果fp1为NULL
						跳到bad处；
					将fp0的类型置为管道类型；
					将fp0的操作模式置为只读；
					将fp0的inode指针置为NULL；
					将fp0的管道指针置为pipe；
					将fp0的文件偏移置为0；
					将fp1的类型置为管道类型；
					将fp1的操作模式置为只写；
					将fp1的inode指针置为NULL；
					将fp1的管道指针置为pipe；
					将fp1的文件偏移置为0；
					将fp0写入*prfile；
					将fp1写入*pwfile；
					返回0；
					
					bad:
					如果fp0不为NULL
						调用函数，丢弃fp0这个引用；
					如果fp1不为NULL
						调用函数，丢弃fp1这个引用；
					如果pipe不为NULL
						调用函数，释放pipe占用的页面；
					返回-1；
					
				关闭管道：
					pipe: 管道指针；
					port: 被关闭管道的端口，以打开文件结构的操作模式为参数，指定只读表示关闭读取端，指定只写表示关闭写入端，指定读写则会PANIC；
					关闭管道指定的端口，并唤醒等待在另一个端口上的进程，如果所有端口都已经被关闭，则释放该管道所使用的页面；无返回值。
					
					关闭中断；
					如果指定关闭读取端口
						将pipe->ropen置为0；
						唤醒等待在pipe->widx上的进程；
					否则如果指定关闭写入端口
						将pipe->wopen置为0；
						唤醒等待在pipe->ridx上的进程；
					否则
						PANIC；
					如果所有端口都已被关闭
						释放该管道所占用的页面；
						恢复原先的中断状态；
					否则
						恢复原先的中断状态；
						
				从管道中读取n字节数据到buf中：
					pipe: 管道指针；
					n: 需要读取的字节数；
					buf: 写入的起始位置；
					
					成功返回实际读取的字节数（总是大于0）；可能会睡眠下去，具体参考设计文档和实现；
					
					关闭中断；
					如果pipe->ropen为0
						PANIC；
					当pipe->ridx等于pipe->widx（即管道为空）且管道的写端口未被关闭，循环执行下述语句
						唤醒等待在pipe->widx上的进程；
						睡眠在pipe->ridx上；
					令i等于n，当i<n时，循环执行下述语句
						如果pipe->ridx等于pipe->widx
							退出循环；
						将pipe->buf[pipe->ridx%sizeof(pipe->buf)]中的数据写入buf[i]中；
						令i++，pipe->ridx++；
					唤醒等待在pipe->widx上的进程；
					恢复原先的中断状态；
					
					返回i；
					
				向管道写入从buf开始的n字节数据：
					pipe: 管道指针；
					n：需要写入的字节数；
					buf: 待写入的数据；
					成功返回实际写入的字节数（总是等于n），失败返回-1；可能会睡眠下去，具体参考设计文档和实现；
					
					关闭中断；
					如果pipe->wopen为0
						PANIC；
					令i等于0，当i<n时，循环执行下述语句
						当pipe->ridx+sizeof(pipe->buf)等于pipe->widx时，循环执行下述语句
							如果管道的读取端已经被关闭
								恢复原先的中断状态；
								返回-1；
							唤醒等待在pipe->ridx上的进程；
							睡眠在pipe->widx上；
						如果管道的读取端已经被关闭
							恢复原先的中断状态；
							返回-1；
						将buf[i]写入pipe->buf[pipe->widx%sizeof(pipe->buf)]中；
						令i++，pipe->widx++；
					唤醒等待在pipe->ridx上的进程；
					恢复原先的中断状态；
					返回n；
					
			文件的组织结构：
				pipe.c: 管道相关操作函数的实现；
				pipe.h: 管道的定义，上述函数的声明；
				
	14.用户程序：
		《1》输出指定文件的信息：
			cmd [-d] [path] ...
			当没有指定path时，等同于执行"cmd ."；
			当指定一个或多个path时，则按照path的顺序依次处理：如果path是目录，且指定了-d选项，则显示该目录本身的信息，没有指定则显示该目录下的文件信息，且不递归处理；如果path不是目录，则显示该path指定文件的信息；所有的path都将处理完而不管其中的失败情况。
			
			成功执行则以0退出，否则以-1退出；
			
		《2》创建目录：
			cmd path ...
			创建一个或多个目录，如果其中某个目录创建失败（已经存在或其他原因）则跳过该目录的创建，继续处理后续需要创建的目录。全部创建成功返回0，否则返回-1。
		《3》添加硬链接：
			cmd path1 path2
			添加一个名为path2的链接指向path1所指向的文件。成功返回0，失败（path1不存在、path2已存在等）返回-1。
		《4》移除目录或文件：【暂不实现】
			cmd [-r] path ...
			移除参数所指定的文件，如果path指定的是目录，且指定了-r，则该目录以及目录下的所有文件都将被删除。如果其中某个文件删除失败则会跳过该文件，继续处理剩余的文件。全部删除成功返回0，失败返回-1。
		《5》从标准输入读取内容，并向标准输出上输出:
			cmd [path] ...
			当没有指定path时，从标准输入循环读取数据，并向标准输出上输出，直到标准输入中没有数据可读（需要ctrl+d的支持，目前未实现）；
			当指定一个或多个path时，则按照path出现的顺序，依次向标准输出输出它们的所有内容；只能读取普通文件。
			
			成功执行则以0退出，否则以-1退出；
		《6》创建文件：
		《7》移除链接：
			cmd path ...
			移除指定链接，如果path指定的是目录且目录不为空，则不会移除该链接。如果某个path无法移除则会跳过该path，继续后续的处理。成功全部移除返回0，否则返回-1。